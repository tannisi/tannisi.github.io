{"meta":{"title":"坦尼斯","subtitle":"默默地接受，并做了自己认为对的事","description":"linux/unix study","author":"tannisi","url":"https://tannisi.top"},"pages":[{"title":"","date":"2018-02-14T02:28:11.828Z","updated":"2018-02-14T02:28:11.792Z","comments":true,"path":"about/index.html","permalink":"https://tannisi.top/about/index.html","excerpt":"","text":"关于博客 坦尼斯是小说龙枪编年史中的人物，他是他的队伍中的领头者，却又是一个令他内心极其矛盾的半精灵，被人类和精灵都不认同。但我喜欢他的睿智、勇敢、正直、信任队友。他就是天生的领导者！ 关于他的队伍：一个法师，一个勇猛的战士，一个高尚的骑士，一个有趣的矮人盗贼，一个充满经验和智慧的老人。一个美丽的精灵女公主，一个法力强大的牧师和保护她的一个信徒。这样的组合在RPG里是不是完美的？ 关于我 目前主要是一名计算机专业的在校大学生，对c语言较为熟悉，同时呢，有代码洁癖感，喜欢整洁、美观的代码。梦想是当一名运维工程师，目前正在朝这方面努力。 对计算机操作系统、数据分析等有一定的了解， 热爱开源项目、热爱新技术、热爱新事物。 关于工作目前没有工作，是一名在校大学生：燕山大学计算机专业的本科生 关于学习正在往终身学习者前进…近期学习方向：Python(推荐系统)、Linux shell运维（主要） 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱排球、台球、阅读、电影、旅行。 联系我 Home: tannisi.top Email: mengtianhaoya@gmail.com GitHub: Guinea pigs WeiBo: 向西人家 Twitter: mengtianhao Facebook: mengtianhao"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-05T04:10:26.000Z","comments":false,"path":"categories/index.html","permalink":"https://tannisi.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-05T04:10:26.000Z","comments":true,"path":"tags/index.html","permalink":"https://tannisi.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"linux运维学习三","slug":"linux运维学习三","date":"2018-02-12T07:20:53.000Z","updated":"2018-03-01T11:57:48.272Z","comments":true,"path":"2018/02/12/linux运维学习三/","link":"","permalink":"https://tannisi.top/2018/02/12/linux运维学习三/","excerpt":"十三、shell中的特殊且重要的变量shell中的特殊位置参数变量 在shell中存在一些特殊且重要的变量，例如：$0、$1、$#，我们称之为特殊位置参数变量。要从命令行、函数、脚本执行性等处传递参数时，就需要在shell脚本中使用位置参数变量。","text":"十三、shell中的特殊且重要的变量shell中的特殊位置参数变量 在shell中存在一些特殊且重要的变量，例如：$0、$1、$#，我们称之为特殊位置参数变量。要从命令行、函数、脚本执行性等处传递参数时，就需要在shell脚本中使用位置参数变量。 常用的特殊位置参数变量表 （1）$1 $2 $9 $(10)…特殊变量实践123456789101112cat p.shecho $1 #&lt;==脚本功能是打印脚本传递的第一个参数的值sh p.sh oldboy #&lt;==传入一个oldboy字符串参数，赋值给脚本中的$1oldboy #&lt;==把传入的oldboy参数赋值给脚本中的$1并传出，因此输出结果为oldboysh p.sh oldboy oldgirl #&lt;==传入两个字符串参数，但脚本不会接受第二个参数，参数默认是以空格分隔oldboy #&lt;==只输出了oldboysh p.sh \"oldboy oldgirl\" #&lt;==加引号括起来的内容传参，会作为一个字符串参数oldboy oldgirl #&lt;==虽然都打印了，但这些内容是作为一个参数传递给$1的cat p.shecho $1 $2 #&lt;==打印脚本传递的第一个、第二个参数的值sh p.sh oldboy oldgirl #&lt;==同时传入两个字符串参数oldboy oldgirl 当位置参数数字大于9时，需要用大括号将数字括起来12cat n.shecho $1 $2 $3 $4 $5 $6 $7 $8 $9 $&#123;10&#125; $&#123;11&#125; $&#123;12&#125; $&#123;13&#125; $&#123;14&#125; $&#123;15&#125; (2)$0特殊变量的作用及变量实践$0的作用为取出执行脚本的名称（包括路径）。下面是该功能的实践。 获取脚本的名称及路径 12cat name.shecho $0 若不带路径执行脚本，那么输出结果就是脚本的名字，如下： 12sh name.shname.sh #&lt;==$0获取的值就是脚本的名字 若使用全路径执行脚本，那么输出的结果就是全路径叫上脚本的名字，如下： 12sh /home/mengtianhao/shellscript/name.sh /home/mengtianhao/shellscript/name.sh 当要执行的脚本为全路径时,$0也会带着路径。此时如果希望单独获取名称或路径，则可用下面的方法。 1234dirname /home/mengtianhao/shellscript/name.sh /home/mengtianhao/shellscript #&lt;==dirname命令的作用是获取脚本的路径basename /home/mengtianhao/shellscript/name.sh name.sh #&lt;==basename命令的作用是获取脚本的名字 (3)$#特殊变量获取脚本传参个数eg:123456# cat q.shecho $1 $2echo $# #&lt;==此行是打印脚本命令行传参的个数#sh q.sh &#123;a..s&#125;a b #&lt;==只接受了两个变量，所以打印了两个字符19 #&lt;==传入了19个参数，因此这里输出的数据为19 应用：可以用在判断脚本传入的参数是不是符合要求。(4)$*和$@特殊变量功能及区别说明123set -- \"I am \" a handsome boy. #&lt;==通过set设置三个字符串参数，“--”表示清除所有的参数变量，重新设置后面的参数变量echo $# #&lt;==输出传入参数的个数4 #&lt;==说明传入了四个参数，双引号里面的视为一个参数 $*的作用为获取当前shell脚本所有传参的参数，不加引号和$@相同。123456for i in $*;do echo $i;doneIamahandsomeboy. 123456for i in $@;do echo $i;doneIam ahandsomeboy. 如果给$*加上双引号，则表示将所有的参数视为单个字符串12for i in \"$*\";do echo $i ;doneI am a handsome boy. 如果给$@加上双引号，则表示将所有的参数视为不同的独立字符串12345for i in \"$@\";do echo $i;doneI ama handsomeboy. shell进程中的特殊状态变量","categories":[{"name":"Linux运维学习","slug":"Linux运维学习","permalink":"https://tannisi.top/categories/Linux运维学习/"}],"tags":[{"name":"Linuxshell","slug":"Linuxshell","permalink":"https://tannisi.top/tags/Linuxshell/"}]},{"title":"有关Ubuntu17.10中fcitx配置搜狗出错的解决方法","slug":"有关Ubuntu17-10中fcitx配置搜狗出错的解决方法","date":"2018-02-10T02:36:21.000Z","updated":"2018-02-10T03:50:55.145Z","comments":true,"path":"2018/02/10/有关Ubuntu17-10中fcitx配置搜狗出错的解决方法/","link":"","permalink":"https://tannisi.top/2018/02/10/有关Ubuntu17-10中fcitx配置搜狗出错的解决方法/","excerpt":"问题描述 关于最近大家在使用Ubuntu系统时出现的fcitx出错的问题，我最近也遇到了，我使用的是Ubuntu17.10。我的问题是在将显卡由英伟达显卡切换到Intel显卡时，出现了fcitx图标，但是sogou输入法不能出现后选项。","text":"问题描述 关于最近大家在使用Ubuntu系统时出现的fcitx出错的问题，我最近也遇到了，我使用的是Ubuntu17.10。我的问题是在将显卡由英伟达显卡切换到Intel显卡时，出现了fcitx图标，但是sogou输入法不能出现后选项。 解决方法 方法一 由于搜狗输入法的配置都在.config目录下，所以使用下列命令将Sogou有关的文件全部删除。12cd .configrm -r Sogou* 然后重装搜狗输入法，重新配置输入法：1.在语言支持中将键盘输入法系统改为fcitx2.使用im-config命令配置输入法，启用fcitx3.打开fcitx配置，添加搜狗输入法。4.然后注销用户，重新进入。 方法二 如果你使用的是googlepinyin，就是用下列命令：12cd .config/fcitxrm googlepinyin 删除掉fcitx配置中的Google拼音，然后重装即可：1sudo apt-get install fcitx-googlepinyin 方法三 重启搜狗输入法，使用下列命令： 123killall fcitxkillall sogou-qinpanelfcitx 方法四 刚安装好的朋友如果无法使用，可以用下面的命令排除或检查修复安装依赖: 1sudo apt-get install -f","categories":[{"name":"Ubuntu问题","slug":"Ubuntu问题","permalink":"https://tannisi.top/categories/Ubuntu问题/"}],"tags":[{"name":"Ubuntu中文输入法解决","slug":"Ubuntu中文输入法解决","permalink":"https://tannisi.top/tags/Ubuntu中文输入法解决/"}]},{"title":"网络层次结构","slug":"网络层次结构","date":"2018-02-08T14:47:41.000Z","updated":"2018-02-10T03:51:00.086Z","comments":true,"path":"2018/02/08/网络层次结构/","link":"","permalink":"https://tannisi.top/2018/02/08/网络层次结构/","excerpt":"一、网络分层的原因网络通信面临的一些问题：硬件故障、网络拥塞、包延迟、包丢失、数据损坏、数据重复、数据乱序","text":"一、网络分层的原因网络通信面临的一些问题：硬件故障、网络拥塞、包延迟、包丢失、数据损坏、数据重复、数据乱序 假设：将所有工作分成面向应用与面向传输两部分 应用程序 QQ、微信、浏览器、播放器 物理连接 网卡等 这种方式的特点： 应用程序完全了解本机网络连接的内部细节 应用程序直接通过网络连接与其它应用程序通信缺点： 会造成大量的重复劳动 扩展性太差现在：将面向传输功能进一步细分为通信软件和物理连接 应用程序 QQ、微信、浏览器、播放器 通信软件 起到“承上启下”的作用 物理连接 网卡等 采用包交换机制在系统中增加若干中间层（主要是网络层），使应用程序不直接处理硬件连接这种设计的好处是： 开发新应用只要遵守通信软件提供的接口即可实现通信功能 出现新网卡时只需扩展通信软件上层应用即可使用新网卡网络之所以使用层次结构的原因：（1）出于复杂问题的解决需要（2）系统功能的扩展性需要二、网络的层次结构层次结构的两大特点： 层次性： 发送方—（由高到低）单向依赖 接收方—（由低到高）单向依赖 结构性：上层起着隐藏下层细节和统一下层差异的作用网络体系结构：网络通信功能的层次构成、各层的通信协议规范和相邻层的接口协议规范的集合。 层次 协议 接口每一层的目的都是向它上一层提供一定服务而把如何实现这一服务的细节对上层加以屏蔽。协议 协议就是一组规则和约定。 计算机网络协议系统：包括一个/多个实体、在物理上明显区分的主体例如：主机、路由器、交换机、AP等实体：系统中能够收发信息和处理信息的任何东西例如：Email、ftp、www 计算机网络协议：网络中两个实体之间控制数据通信的规则和约定的集合。计算机网络协议的要素 语法（数据结构、编码和信号电平等）：1.消息格式、编码 2.HTML网页表示 3.TCP报文格式 语义（用于协调和差错处理的控制信息）：1.双方“握手”控制信息2.TCP 一方主动发出建立请求3.TCP另一方表态是否同意或拒绝连接 时序（传输速率匹配和事件先后顺序）：1.双方握手过程规定2.先和服务器建立TCP连接3.在请求某个HTML网页层次结构的有关概念 第n层协议：一台机器的第n层与另一台机器的的第n层进行通话采用的规则和约定。 对等实体：不同机器中组成相同协议层的实体 接口：位于相邻层间，定义下层向上层提供的原语操作和服务 协议栈：特定系统使用的一组协议计算机网络体系结构分层原则 协议分层原则：目标机器第n层收到的对象应与源机器第n层发出的“对象”完全一致 协议栈 ：1.上层隐藏下层的细节 2.上层统一下层的差异 3.上层弥补下层的不足层次划分设计的问题 标识接收方/发送方机制：机器上的进程需要某种手段标识它想和哪个进程通话 数据传输规则：传输形式、数据的顺序、收发双方的同步。。。 差错控制：确定错误检测和错误纠正方法 多路复用：下层可决定为多个上层通信使用同一个连接 路由选择：在多条可能的路径中选定一条三、网络协议与服务服务提供者与服务使用者 服务提供者：使用下层服务的实体服务使用者：为上层提供服务的实体 第N层实体：1.实现的功能为N+1层使用2.利用第N-1层来实现本层的功能 3.既是第N+1层的服务提供者又是第N-1层服务用户服务分类（1）面向连接 有连接服务/面向连接服务：1.类似于电话服务 2.本质上数据结构是一个管道 其发送的形式有两种：1.报文序列：保持发送数据的边界 2.不保次发送数据的边界（2）无连接 无连接服务：1.类似于邮政服务 2.每次发送一个报文 3.每个报文都给出详细的目标地址信息 其根据服务质量可划分为两种：1.无确认：不能确定接收方是否收到 2.有确认：能确认发送是否成功如何使用下层服务 服务：形式上由一组原语（操作）来描述 原语：上下两层通信形式 参数：用来传递数据和控制信息 国际上定义的4个原语：1.Request：由服务使用者发出/要求服务做某种工作2.Indication：由服务提供者发出/通知发生了某事件3.Respone：由服务使用者发出/表示对某个事件的响应4.Confirm：由服务提供者发出/报告事件的响应 服务原语的时序性服务与协议是完全分离的 服务（上下关系）：1.服务是各层向它的上层提供的一组原语（操作）2.服务定义了该层能为它的用户完成的操作 3.服务只与两层之间的接口有关 协议（水平关系）：1.协议是一组规则 2.决定同层对等实体交换帧、包和报文的格式和意义 3.实体用协议来实现他们向上层提供的服务四、网络标准与标准化组织 标准化是规模化的基础优点：1.能保证设备/软件有一个大市场 2.允许来自多个厂商产品的互通 3.使用户在设备选择和使用中有更多的灵活性 标准及其分类标准：标准是一组规定的规则、条件或要求 一些有关的标准化组织ITU ISO ANSI IEEE（制定通信和信息系统领域的标准）因特网标准：IRTF IETF RFC五、TCP-IP模型及因特网 TCP是传输层的协议 IP是网络层的协议 TCP/IP设计目标：1.互联网络 2.保护子网硬件 3.体系结构灵活 4.网络故障不能影响两端之间连接 应用层 传输层 网络层 主机-网络层————&gt;交换机、集线器、接入点（802.3/802.11） 主机-网络层（1）主要功能：1.端系统与其所接网络之间的数据交换 2.特定软件取决于所用的网络类型（2）设计优点：1.将网络访问功能隔离成一个单独层次 2.网络访问层之上的通信软件不必关心所用的网络类型（3）又分为两层： 物理层：1.设备与介质/网络之间的物理接口 2.规范传输介质特性，信号、数据率及相关方面 网络访问层：1.主机与网络之间的数据交换 2.发送主机必须向网络提供目的主机的地址 网络互联层（互联协议：IP、ICMP、IGMP、ARP/RAPP、BGP/OSPF）基本任务：1.采用存储-转发技术 2.提供Best-effort服务 3.处理来自传输层的报文发送请求（主机）4.处理入境数据包的转发（路由器） 5.处理ICMP报文传输层（TCP/UDP）（1）主要功能：1.提供端-端的数据传送服务2.为应用层隐藏底层网络的细节（2）TCP/IP在无连接的基本传送服务IP之上既提供了无连接服务，也提供了可靠的有连接服务 应用层应用层服务：1.虚拟终端（TELNET）协议2.文件传输协议（FTP）3.简单邮件传输协议（SMTP）4.域名服务（DNS）5.超文本传输协议（HTTP）","categories":[{"name":"网络原理","slug":"网络原理","permalink":"https://tannisi.top/categories/网络原理/"}],"tags":[{"name":"网络层次结构","slug":"网络层次结构","permalink":"https://tannisi.top/tags/网络层次结构/"}]},{"title":"linux运维学习二","slug":"linux运维学习二","date":"2018-02-08T02:38:50.000Z","updated":"2018-02-12T07:08:00.646Z","comments":true,"path":"2018/02/08/linux运维学习二/","link":"","permalink":"https://tannisi.top/2018/02/08/linux运维学习二/","excerpt":"十、变量变量的赋值方式 先写变量名称，紧接着是“=”这个字符，最后是值。中间无任何空格，通过echo命令加上$oldboy即可输出oldboy变量的值，变量的内容一般要加双引号，以防止出错。特别是当值里的内容之间有空格时。","text":"十、变量变量的赋值方式 先写变量名称，紧接着是“=”这个字符，最后是值。中间无任何空格，通过echo命令加上$oldboy即可输出oldboy变量的值，变量的内容一般要加双引号，以防止出错。特别是当值里的内容之间有空格时。 $ oldboy=’I am a boy’ $ echo $oldboy I am a boy shell变量的特性 默认情况下，在bash shell中是不会区分变量的类型的。但是如果需要指定shell变量的类型，也可以使用declare显示定义变量的类型。 变量类型 分为两类：环境变量（全局变量）和普通变量（局部变量）环境变量（全局变量），可以在创建它们的shell及其派生出来的的任意子进程shell中使用，环境变量又可分为自定义环境变量和bash内置的环境变量。普通变量（局部变量）只能在创建他们的shell函数或shell脚本中使用。普通变量一般由开发者在开发脚本程序时创建 。 十一、环境变量环境变量定义 环境变量一般是指用export内置命令导出的变量，用于定义shell的运行环境，保证shell命令的正确执行。shell通过环境变量来确定登录用户名、命令路径、终端类型、登录目录等，所有的环境变量都是系统全局变量，可用于所有的子进程中，这包括编辑器、shell 脚本和各类应用。 环境变量可以在命令行中设置和创建，但用户退出命令行时这些变量值就会丢失，因此，如果希望永久保存环境变量，可在用户家目录下的.bash_profile或.bashrc（非用户登录模式特有，例如远程ssh）文件中，或者全局配置/etc/bashrc（非用户登录模式特有，例如远程ssh）或/etc/profile文件中定义。在将环境变量放入上述的文件中后，每次用户登录时这些变量都将被初始化。 按照系统规范，所有环境变量的名字均采用大写形式。在将环境变量应用于用户进程程序之前，都应该用export命令导出定义，例如：正确的环境变量定义方法为export OLDGIRL=1。 有一些环境变量，比如HOME、PATH、SHELL、UID、 USER等，在用户登录之前，就已经被/bin/login程序设置好了。通常环境变量被定义并保存在用户家目录下的.bash_profile文件或全局的配置文件/etc/profile中。常见的环境变量： PATH： 决定了shell将到哪些目录中寻找命令或程序 ROOTPATH: 这个变量的功能和PATH相同，但它只罗列出超级用户（root）键入命令时所需检查的目录。 HOME： 当前用户主目录 USER: 查看当前的用户 LOGNAME： 查看当前用户的登录名。 UID： 当前用户的识别字，取值是由数位构成的字串。 SHELL： 是指当前用户用的是哪种Shell。 TERM ： 终端的类型。 PWD： 当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化。 MAIL： 是指当前用户的邮件存放目录。 HISTSIZE： 是指保存历史命令记录的条数 HOSTNAME： 是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。 PS1： 是基本提示符，对于root用户是#，对于普通用户是$，也可以使用一些更复杂的值。 PS2： 是附属提示符，默认是“&gt;”。可以通过修改此环境变量来修改当前的命令符，比如下列命令会将提示符 修改成字符串“Hello,My NewPrompt :) ”。# PS1=” Hello,My NewPrompt :)” IFS： 输入域分隔符。当shell读取输入时，用来分隔单词的一组字符，它们通常是空格、制表符和换行符。 _=： 上一条命令的最后一个参数 在查看设置的变量时，有三个命令可以显示变量的值：set、env和declare（替代早期的typeset）。set命令输出所有的变量，包括全局变量和局部变量；env命令只显示全局变量，declare命令输出所有的变量、函数、整数和已经导出的变量。set -o命令显示bash shell的所有参数配置信息。 $ set -o|tail #&lt;==tail输出输入文件的后10行 $ set -o|head #&lt;==head输出输入文件的前10行 设置环境变量如果要设置环境变量，就要在给变量赋值之后活在设置变量时使用export命令。（带-x选项的declare内置命令也可以完成同样的功能）。export和declare命令的格式如下： 1.export 变量名=value 2.变量名=value ; export 变量名 3.declare -x 变量名=value下面是自定义全局环境变量的示例： $ grep OLD /etc/profile $ export OLDBOY=&apos;oldboy&apos; #&lt;==编辑/etc/profile,然后输出并保存 $ source /etc/profile #&lt;==执行使其生效 $ echo $OLDBOY oldboy $ env|grep OLDBOY #&lt;==查看定义结果 OLDBOY=oldboy 下面来看看让环境变量永久生效的常用设置文件。1）用户的环境变量配置配置如下： $ ls /root/.bashrc #&lt;==一定要在root权限下执行 /root/.bashrc $ ls /root/.bashrc_profile #&lt;==在ubuntu中没有.bashrc_profile文件，有.profile文件 /root/.bashrc_profile 2）全局环境变量的配置常见的全局环境变量的配置文件如下： /etc/profile /etc/bashrc #&lt;==推荐在此文件中优先设置 /etc/profile.d/ 若要在登录后初始化或显示加载内容，则把脚本文件放在/etc/profile.d/下即可（无需加执行权限）。（2）设置登录提示的两种方式第一种是在/etc/motd里增加提示的字符串，如下： $cat /etc/motd welcome to linux shell training. 则登陆后显示内容如下： Last login : Fri Nov 7 15 :36 : 56 2017 from 10.0.0.100 welcome to linux shell training 第二种是在/etc/profile.d/下面增加如下脚本： $ cat /etc/profile.d/oldboy.sh echo &quot;Here is a oldboy training&quot; 登陆后显示的内容如下： Last login : Fri Nov 7 15 :36 : 56 2017 from 10.0.0.100 Here is a oldboy training 以下是在生产场景下（在Java环境中），自定义环境变量的示例： export JAVA_HOME=/application/jdk export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin export RESIN_HOME=/application/resin 上述的环境变量通常放在/etc/profile全局变量里。如果是写JAVA的脚本，那么最好是把上述Java环境配置放入脚本内重新定义，特别是作为定时任务执行的脚本。 显示与取消环境变量1.通过echo或printf命令打印环境变量常见的系统环境变量：$HOME：用户登录时进入的目录$UID：当前用户的UID（用户标识），相当于id-u$PWD：当前工作目录的绝对路径名$SHELL：当前shell$USER：当前用户 在写shell脚本时可以直接使用系统默认的环境变量，一般情况下是不需要重新定义的，在使用定时任务等执行shell脚本时建议在脚本中重新定义。 2.用env或set显示默认的环境变量 3.用unset消除本地变量和环境变量 $ echo $USER boyboy $ unset USER $ echo $USER #&lt;==此处为输出的空行，即消除了环境变量。 环境变量知识小结： 变量名通常要大写 变量可以在自身的shell及子shell中使用 常用export来定义环境变量 执行env默认可以显示所有的环境变量名称及其对应的值 输出时用“$变量名”，取消时用“unset变量名” 书写crond定时任务时要注意，脚本要用到的环境变量最好先在所执行的shell脚本中重新定义 如果希望环境变量永久生效，则可以将其放在用户环境变量文件或全局环境变量文件中。环境变量初始化与对应文件的生效顺序 在登录Linux系统并启动一个bash shell时，默认情况下bash会在系统环境文件中查找环境变量的设置。bash检查的环境变量文件的情况取决于系统运行shell的方式。系统运行shell的方式一般有3种： 1)通过系统用户登录后默认运行的shell 2）非登录交互式运行shell 3）执行脚本运行非交互式shell当用户登录Linux系统时，shell会作为登录shell启动。此时的登录shell加载环境变量的顺序。 首先加载/etc/profile全局环境变量文件，这是Linux系统上默认的shell主环境变量，系统上每个用户登录时都会加载这个文件 再执行/etc/profile.d目录下的脚本文件 然后运行$HOME/.bash_profile(用户环境变量文件)，在这个文件中，又会去找$HOME/.bashrc(用户环境变量文件)，如果有则执行，如果没有，则不执行。在$HOME/.bashrc文件中又会去找/etc/bashrc(全局环境变量文件)，如果有则执行，如果没有则不执行。 如果用户的shell不是在登录时启动的，那么这种非登录Shell只会加载$HOME/.bashrc(用户环境变量文件),并会去找/etc/bashrc(全局环境变量文件)。 因此若希望在非登录shell下也可读到设置的环境变的内容，就需要将变量设定等写入$HOME/.bashrc或者/etc/bashrc,而不是$HOME/.bash_profile或/etc/profile。 以上是在centos中的环境变量启动顺序，在ubuntu系统中： /etc/profile：在登录时操作系统定制用户环境时使用的第一个文件，此文件为系统的每个用户设置环境信息。当用户第一次登录时，该文件被执行。 /etc/environment:在登录时操作系统使用的第二个文件，系统在读取你自己的profile前，设置环境文件的环境变量。 /etc/bashrc:为每一个运行bash shell的用户执行此文件。当bash shell被打开时，该文件被读取。 ~/.profile:在登录时用到的第三个文件是.profile文件，当用户登录时，该文件仅仅执行一次！默认情况下，执行用户目录下的.bashrc文件，每个用户都可使用该文件输入专用于自己使用的shell信息，修改后使用. .profile使生效。 ~/.bashrc:该文件包含专用于单个用户的bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取。修改后使用source .bashrc 使生效。 在ubuntu中设置环境变量： 通常设置环境变量有三种方法：（一）临时设置 $PATH=/home/yan/share/usr/local/arm/3.4.1/bin:$PATH（二）当前用户的全局设置打开~/.bashrc，添加行： export PATH=/home/yan/share/usr/local/arm/3.4.1/bin:$PATH使生效： source .bashrc（三）所有用户的全局设置 $ vim /etc/profile在里面加入： export PATH=/home/yan/share/usr/local/arm/3.4.1/bin:$PATH使生效 source profile测试： echo $PATH十二、普通变量定义本地变量 本地变量在用户当前shell生存期的脚本中使用。 普通变量定义变量名=value变量名=’value’变量名=”value” 在shell中定义变量名及为变量内容赋值的要求 变量名一般是由字母、数字、下划线组成的，可以以字母或下划线开头。变量的内容可以用单引号或双引号引起来，也可不加引号，但是三者的含义是不同的。 普通变量的定义及输出的示例123456789$ a=192.168.1.2$ b='192.168.1.2'$ c=\"192.168.1.2\"$ echo \"a=$a\"a=192.168.1.2$ echo \"b=$b\"b=192.168.1.2$ echo \"c=$&#123;c&#125;\"c=192.168.1.2 【$变量名表示输出变量，可以用$c和${c}两种用法】 将连续的普通字符串的内容赋值给变量，不管用不用引号，或者不管用什么用引号，它的内容是什么，打印变量时就会输出什么。123456789$ a=192.168.1.2-$a$ b='192.168.1.2-$a'$ c=\"192.168.1.2-$a\"$ echo \"a=$a\"a=192.168.1.2-192.168.1.2$ echo \"b=$b\"b=192.168.1.2-$a$ echo \"c=$&#123;c&#125;\"c=192.168.1.2-192.168.1.2-192.168.1.2 变量定义的基本技巧总结1a=192.168.1.2-$a 第一种a定义变量的方式是不加任何引号直接定义变量的内容，当内容为简单连续的数字、字符串、路径名时，就可以这样用。不加引号时，值里有变量的会被解析后再输出。1b='192.168.1.2-$a' 第二种输出变量内容时单引号里是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合于定义显示纯字符串的情况，即不希望解析变量、命令等的情形。1c=\"192.168.1.2-$a\" 第三种输出变量内容时引号里的变量及命令会经过解析再输出内容，而不是把双引号中的变量名及命令（命令需要反引起来）原样输出。这种方式比较适合于字符串中附带有变量及命令且想将其解析后再输出的变量定义。 把一个变量的结果作为变量的内容赋值的方法常见的方法有两种：12变量名=`ls` #&lt;==把命令用反引号引起来变量名=$(ls) #&lt;==把命令用$()括起来，推荐使用这种方法 局部（普通）变量定义及赋值的小结（1）常规普通变量定义 若变量内容为连续的数字或字符串，赋值时，变量内容两边可以不加引号，例如：a=123 变量的内容很多时，如果有空格且希望解析内容中的变量，就加双引号。 希望原样输出变量中的内容时就用单引号引起内容并进行赋值。 要使用反引号将赋值的命令括起来，例如a=ls；或者用$()括起来，例如：a=$(ls)。（2）变量的输出方法如下： 使用“$变量名”即可输出变量的内容，常用”echo$变量名“的方式，也可用printf代替echo输出更复杂的格式内容。（3）变量定义的技巧及注意事项 注意命令变量内容前后的字符``（此字符是键盘上的tab键上面的那个反引号，不是单引号）。 在变量名前加$可以取得该变量的值，使用echo或printf命令可以显示变量的值。 用echo等命令输出变量的时候，也可用单引号、双引号、反引号。 $dbname_tname，当变量后面连接有其他字符的时候，必须给变量加上大括号{},例如：$dbname_tname就要变成${dbname}_tname。这是shell就会认为只有dbname是变量了。变量定义及变量输出说明单引号、双引号、反引号与不加引号的知识说明表 名称 解释 单引号 所见即所得，即输出时会将单引号内的所有内容都原样输出，或者描述为单引号里面看到的是什么就会输出什么，这称为强引用 双引号(默认) 输出双引号内的所有内容；如果内容中有命令（要反引下）、变量、特殊转义符等，会先把变量 、命令、转义字符解析出结果，然后再输出最终的内容，推荐使用，这称为弱引用 无引号 赋值时，若变量中有空格，则会造成赋值不完整。而在输出内容时，会将含有空格的字符串视为一个整体来输出；如果内容中有命令(要反引下)、变量等，则会先把变量、命令解析出结果，然后输出最终结果；如果字符串中带有空格等特殊字符，则有可能无法完整地输出，因此需要改加双引号。一般连续的字符串、数字、路径等可以不加任何引号进行赋值和输出，不过最好是用双引号替代无引号的情况，特别是对变量赋值时。 反引号 一般用于引用命令，执行的时候命令会被执行，相当于$()，赋值和输出时都要用反引号将命令引起来 ！这里仅为Linux shell 下的结论，对于awk语言会有点特别，有关awk调用shell变量的详情，请自行查询。不过，在awk取用shell变量时，我们更多地还是喜欢先用echo加符号输出变量，然后通过管道给awk，进而控制变量的输出结果。建议： 在脚本中定义普通字符串变量时，应尽量把变量的内容用双引号括起来。 单纯数字的变量内容可以不加引号 希望变量的内容原样输出时需要加单引号 希望变量值引用命令并获取命令的结果时就用反引号或$() 变量定义技巧总结（1）变量名及变量内容定义小结 变量名只能为字母、数字或下划线，只能以字母或下划线开头。 变量名的定义要有一定的规范，并且要见名知意。 一般的变量定义、赋值常用双引号；简单连续的字符串可以不加引号；希望原样输出时使用单引号。 希望变量的内容是命令的解析结果时，要用反引号，或者$()把命令括起来再赋值（2）shell定义变量时使用“=”的知识 “a=1”里等号是赋值的意思；比较变量是否相等时也可以用“=”或“==”。（3）打印输出及使用变量的知识 打印输出或使用变量时，变量名前要接$符号；变量名后面紧接其他字符时，要用大括号将变量部分单独括起来；在unset、export、（()）等场景中使用但不打印变量时不加$，这个有些例外。 打印输出或使用变量时，一般加双引号或不加引号；如果是字符串变量，最好加双引号；希望原样输出时使用单引号。","categories":[{"name":"Linux运维学习","slug":"Linux运维学习","permalink":"https://tannisi.top/categories/Linux运维学习/"}],"tags":[{"name":"Linuxshell","slug":"Linuxshell","permalink":"https://tannisi.top/tags/Linuxshell/"}]},{"title":"linux运维学习一","slug":"linux运维学习一","date":"2018-02-07T04:09:55.000Z","updated":"2018-02-07T05:17:15.468Z","comments":true,"path":"2018/02/07/linux运维学习一/","link":"","permalink":"https://tannisi.top/2018/02/07/linux运维学习一/","excerpt":"Linux运维学习一、shell脚本 当命令或程序语句不在命令行下执行，而是通过一个程序文件来执行时，该程序就被称为shell脚本。","text":"Linux运维学习一、shell脚本 当命令或程序语句不在命令行下执行，而是通过一个程序文件来执行时，该程序就被称为shell脚本。 二、清除/var/log下messages日志文件的简单命令脚本#!/bin/bash # 清除日志脚本 LOG_DIR=/var/log ROOT_UID=0 #&lt;==$UID为0的用户，即root用户 if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ] then echo &quot;MUST be root to run this script.&quot; exit 1 fi cd $LOG_DIR || { echo &quot;Cannot change to necessary directory&quot; exit 1 } cat /dev/null&gt;messages &amp;&amp; { echo &quot;Logs cleaned up.&quot; exit 0 } echo &quot;Logs cleaned up fail.&quot; exit 1 上面的脚本设计成了如下几关：第一关：必须是root才能执行脚本，否则会给出友好提示并终止脚本运行第二关：成功切换目录（cd /var/log）,否则给出友好提示并终止脚本运行第三关：清理日志（cat /dev/null&gt;messages），若清理成功，则给出正确提示。第四关：通过或失败，分别给出相应的提示（echo输出） 三、shell脚本语言是弱类型语言（无需定义变量的类型即可使用），在UNIX/LINUX中主要有两大类shell：Bourne shell 和 C shell（1）查看系统的shell支持情况。$ cat /etc/shells（2）查看系统默认的shell。方法一：echo $SHELL /bin/bash方法二：grep root /etc/passwd root:x:0:0:root:/root:/bin/bash 四、shell脚本的建立（1）脚本开头。一个规范的shell脚本会在第一行指出由哪个程序（解释器）来执行脚本中的内容，这一行内容在Linux bash的编程一般为：#!/bin/bash（2）查看系统的bash版本的命令。bash –version（3）检测系统是否存在漏洞的方法。env x=’() { :;}; echo be careful’ bash -c “echo this is a test”如果出现：this is a test 则没有漏洞。否则，则需尽快升级bash了。（4）下面是Linux中常用的脚本开头的写法。 #!/bin/bash #!/bin/sh #!/usr/bin/awk #!/bin/sed #!/usr/bin/tcl #!/usr/bin/expect #&lt;==expect解决交互式的语言开头解释器 #!/usr/bin/perl #&lt;==Perl语言解释器 #!/usr/bin/env python #&lt;==python语言解释器 如果在脚本开头的第一行不指定解释器，那么就要用对应的解释器来执行脚本。这样才能确保脚本正确执行。例如：如果是shell脚本，就用bash test.sh执行test.sh如果是Python脚本，就用python test.py执行test.py如果是expect脚本，就用expect test.exp执行test.exp（5）脚本注释在shell脚本中，跟在#后面的内容表示注释，用来对脚本进行注释说明。 五、shell脚本的执行通常采用以下几种方式：（1）bash script-name 或 sh script-name：这是当脚本文件本身没有可执行权限（即文件权限属性x位为-号）时常用的方法，或者脚本文件开头没有指定解释器时需要使用的方法。（2）path/script-name 或 ./script-name ：指在当前路径下执行脚本（脚本需要有执行权限），然后就直接应用了。可以使用chmod命令来变更文件或目录的权限。权限的表示法如下: u User，即文件或目录的拥有者； g Group，即文件或目录的所属群组； o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围； a All，即全部的用户，包含拥有者，所属群组以及其他用户； r 读取权限，数字代号为“4”; w 写入权限，数字代号为“2”； x 执行或切换权限，数字代号为“1”； - 不具任何权限，数字代号为“0”； s 特殊功能说明：变更文件或目录的权限。 （3）source script-name 或 . script-name ：这种方法通常是使用source或“.”读入或加载指定的shell脚本文件，然后依次执行指定的shell脚本文件中的所有语句。这些语句将在当前父shell脚本father.sh进程中运行（其他几种模式都会启动新的进程执行子脚本）。因此，使用source或“.”可以将son.sh自身脚本中的变量值或函数等的返回值传递到当前父shell脚本father.sh中使用。（4）sh&lt;script-name或cat script-name|sh：这种方法将所有的字符串拼接为命令的形式，然后经由管道交给bash操作的案例。 六、给test.sh添加可执行权限. 命令如下：chmod u+x test.sh 然后test.sh就拥有了可执行权限了。可以使用上面的第二种方法了。即：. /test.sh 七、使用第三种方法时会将source或“.”执行的脚本中的变量值传递到当前的shell中.$ echo &apos;userdir=`pwd`&apos; &gt;testsource.sh $ cat testsource.sh userdir=`pwd` $ sh testsource.sh #&lt;==采用sh命令执行脚本 $ echo $userdir #&lt;==此处为空并没有出现当前路径/home/tianhao/shellscript 通过sh或bash命令执行过的脚本，若在脚本结束之后在当前shell窗口中查看usedir变量的值，会发现值是空的。如果以同样的步骤改用source或“.”执行，然后看userdir变量的值。 $ source testsource.sh $ echo $userdir /home/tianhao/shellscript 结论：通过source或“.”加载执行过的脚本，由于是在当前shell中执行脚本，因此在脚本结束之后，脚本中的变量（包括函数）值在当前shell中仍然存在，而sh和bash执行脚本都会启动新的子shell执行，执行完后退回到父shell。因此，变量（包括函数）值等无法保留。在进行shell脚本开发时，如果脚本中有引用或执行其他脚本的内容或配置文件的需求时，最好用“.”或source先加载该脚本或配置文件，处理完之后，再将他们加载到脚本的下面，就可以调用source加载的脚本及配置文件中的变量及函数等内容了。 八、采用第四种方法来实践：$ cat test.sh !#/bin/bash echo &quot;I am a good boy&quot; $ cat test.sh|bash #&lt;==这种方法在命令行拼接字符串命令后，需要执行时就会用到 I am a good boy 九、shell脚本开发的基本规范及习惯。基本规范：（1）shell脚本的第一行是指定脚本解释器，通常为： !#/bin/bash（2）shell脚本的开头会加版本、版权等信息： # Date: 16:29 2017-12-30 #Author: Created by tianhao #Description: This is ... #version: 1.1 可修改”~/.vimrc”配置文件vim编辑文件是自动加上以上信息的功能。（3）在shell脚本中尽量不用中文，注释也是如此。如果非要加中文，请根据自身的客户端对系统进行字符集的调整，如：export LANG=”zh_CN.UTF-8”,并在脚本中，重新定义字符集设置，和系统保持一致。（4）shell脚本的命名应以.sh为扩展名。（5）shell脚本应存放在固定的路径下。例如： /server/scripts习惯：（1）成对的符号应尽量一次性写出来，然后退格在符号里增加内容，以防止遗漏。（2）中括号（[]）两端至少要有1个空格，因此，键入中括号时即可留出空格（[ ]），然后再退格键入中间的内容，并确保两端都至少有一个空格。双中括号的写法也是如此。（3）对于流程控制语句，应一次性将格式写完，再添加内容。（4）注意代码缩进。（5）对于常规变量的字符串定义变量值应加双引号，并且等号前后不能有空格，需要强引用的（指所见即所得的字符引用），则用单引号（’’），若是命令的引用，则用反引号(``)。（6）脚本中的单引号、双引号及反引号必须为英文状态下的符号，其实所有的Linux字符及符号都应该是英文状态下的符号。","categories":[{"name":"Linux运维学习","slug":"Linux运维学习","permalink":"https://tannisi.top/categories/Linux运维学习/"}],"tags":[{"name":"Linuxshell","slug":"Linuxshell","permalink":"https://tannisi.top/tags/Linuxshell/"}]},{"title":"进程与线程（三）","slug":"进程与线程（三）","date":"2018-02-03T04:11:55.000Z","updated":"2018-02-03T04:12:30.359Z","comments":true,"path":"2018/02/03/进程与线程（三）/","link":"","permalink":"https://tannisi.top/2018/02/03/进程与线程（三）/","excerpt":"","text":"","categories":[{"name":"现代操作系统学习","slug":"现代操作系统学习","permalink":"https://tannisi.top/categories/现代操作系统学习/"}],"tags":[{"name":"进程与线程","slug":"进程与线程","permalink":"https://tannisi.top/tags/进程与线程/"}]},{"title":"进程与线程（二）","slug":"进程与线程（二）","date":"2018-01-26T04:13:55.000Z","updated":"2018-02-07T06:14:18.243Z","comments":true,"path":"2018/01/26/进程与线程（二）/","link":"","permalink":"https://tannisi.top/2018/01/26/进程与线程（二）/","excerpt":"线程 在传统操作系统中，每个进程有一个地址空间和一个控制线程。事实上这几乎就是进程的定义。不过经常存在在同一个地址空间中准并行运行多个控制线程的情形，这些线程就像分离的进程一样（共享地址空间除外）。 线程的使用 原因：（1）主要原因：在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型就会变得很简单。【只是在有了多线程的概念之后，我们才加入了一种新的元素：并行实体拥有共享同一个地址空间和所有可用数据的能力。】","text":"线程 在传统操作系统中，每个进程有一个地址空间和一个控制线程。事实上这几乎就是进程的定义。不过经常存在在同一个地址空间中准并行运行多个控制线程的情形，这些线程就像分离的进程一样（共享地址空间除外）。 线程的使用 原因：（1）主要原因：在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型就会变得很简单。【只是在有了多线程的概念之后，我们才加入了一种新的元素：并行实体拥有共享同一个地址空间和所有可用数据的能力。】（2）由于线程比进程更轻量级，所以它们比进城更容易（更快）创建，也更容易撤销。在许多系统中，创建一个线程较创建一个进程要快10~100倍。在有大量线程需要动态和快速修改时，具有这一特性是非常有用的。（3）有关性能方面，如果多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。在多CPU系统中，多线程是有益的，在这样的系统中，真正的并行有了实现的可能。下面我举个例子来说明引入多线程的好处： 假设用户正在写一本书。如果整本书是个文件，那么只要一个命令就可已完成全部的替换处理。相反，如果一本书分成了300个文件，那么就必须分别对每个文件进行编辑。现在考虑，如果有一个用户突然在一个有800页的文件的第一页上删掉了一个语句之后，会发生什么情形。在检查了所修改的页面并确认正确之后，这个用户现在打算接着在第600页上进行进行另一个修改，被强制对整本书的前600页重新进行格式处理， 这是因为在排列该页前面的所有页之前，字处理软件并不知道第600页的第一行应该在哪里。而在第600页的页面可以真正在屏幕上显示出来之前，计算机可能要拖延相当一段时间，从而令用户不甚满意。 这时，多线程可以在这里发挥作用。假设字处理软件被编写成含有两个线程的程序。一个线程与用户交互，而另一个在后台重新进行格式处理。一旦在第一页中的语句被删除掉，交互线程就立即通知格式化线程对整本书重新进行处理。同时，交互线程继续监控键盘和鼠标，并相应诸如滚动第1页之类的简单命令，此刻，另一个线程正在后台疯狂的运算，如果有点运气的话，重新格式化会在用户请求查看第600页之前完成，这样，第600页页面就立即可以在屏幕上显示出来。 我们可以在增加一个线程。许多字处理软件都有每隔若干分钟自动在磁盘上保存整个文件的特点，用于避免由于程序崩溃、系统崩溃或电源故障而造成用户一整天的工作丢失的情况。第三个线程可以用于处理磁盘备份，而不必干扰其他两个进程。拥有三个线程的情形如下图所示： 很显然，在这里用三个不同的进程是不能工作的，这是因为三个进程都需要对同一个文件进行操作。由于多个线程可以共享公共内存，所以通过用三个线程替代三个进程，使得他们可以访问同一个正在编辑的文件，而三个进程是做不到的。 现在考虑另一个多线程发挥作用的例子：一个万维网服务器。对页面的请求发送给服务器，而所请求的页面发送给客户机。在多数web站点上，某些页面较其他页面相比，有更多的访问。例如，对Sony主页的访问就远远超过对深藏在页面树里的任何特定摄像机的技术说明书页面的访问。利用这一事实，web服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能。这样的一种页面集合称为高速缓存. web服务器的3种设计方案多线程web服务器： 一种组织web服务器的方式如上图所示，在这里，一个称为分派程序的线程从网络中读入工作请求。在检查请求之后，分派线程挑选一个空转的（即被阻塞的）工作线程，提交请求，通常是在每个线程所配有的某个专门的字中写入一个消息指针。接着分派线程唤醒睡眠的工作线程，将它从阻塞状态转为就绪状态。 在工作线程被唤醒之后，它检查有关的请求是否在web高速页面缓存之中，这个高速缓存是所有线程都可以访问的。如果没有，该线程开始一个从磁盘调入页面的read操作并且阻塞直到该磁盘操作完成。当上述线程阻塞在磁盘操作上时，为了完成更多的工作，分派线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。 这种模型允许把服务器编写为顺序线程的一个集合。 在分配线程的程序中包含一个无限循环，该循环用来获得工作请求并把工作请求派给工作线程。每个工作线程的代码包含一个从分派线程接受的请求，并且检查web高速缓存中是否存在所需页面的无限循环如果存在，就将该页面返回给客户机，接着该工作线程阻塞，等待一个新的请求。如果没有，工作线程就从磁盘调入该页面，将该页面返回给客户机，然后该工作线程阻塞，等待一个新的请求。 下图给出了有关代码的大致框架（TRUE=1，buf和page分别是保存工作请求和web页面的相应结构）： 单线程web服务器： 一种可能的方式使其像一个线程一样运行。web服务器的主循环获得请求，检查请求，并且在取下一个请求之前完成整个工作。在等待磁盘操作时，服务器就空转，并且不处理任何到来的其他请求。如果该web服务器运行在唯一的机器上，通常情形都是这样的，那么在等待磁盘操作时CPU只能空转。结果导致每秒钟只有很少的请求被处理。可见线程较好地改善了web服务器的性能，而且每个线程是按通常方式顺序编程的。 有限状态机： 如果可以使用read系统调用的非阻塞版本，还存在第三种可能的设计。在请求到来时，这个唯一的线程对请求进行考察。如果该请求能够在高速缓存中得到满足，那么一切都好，如果不能，则启动一个非阻塞的磁盘操作 。 服务器在表格中记录当前请求的状态，然后去处理下一个事件。下一个事件可能是一个新工作的请求，或是对磁盘先前操作的回答。如果是新工作的请求，就开始工作。如果是磁盘的回答，就从表格中取出对应的消息，并处理该回答，对于非阻塞磁盘I/O而言，这种回答多数会以信号或中断的形式出现。 在这种设计中，每次服务器从为某个请求工作的状态切换到另一个状态时，都必须显示地保存或重新装入相应的计算状态。事实上，我们以一种困难的方式模拟了线程及其堆栈。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为有限状态机。 下图给出了上述模式的总结： 多线程提供了一种解决方案，有关的进程可以用一个输入线程、一个处理线程和一个输出线程构造。输入线程把数据读入到到输入缓冲区中；处理线程从输入缓冲区中取出数据，处理数据，并把结果放到输出缓冲区中；输出线程把这些结果写到磁盘上。按照这种工作方式，输入、处理和输出可以全部同时进行。当然这种模型只有当系统调用只阻塞调用线程而不是阻塞整个进程时，才能正常工作。 经典的线程模型 进程模型基于两种独立的概念：资源分组处理与执行。有时将这两种概念分开会更好，于是引入了“线程”这一概念。 理解进程的一个角度是，用某种方法把相关资源集中在一起。进程有存放程序正文和数据以及其他资源的地址空间。这些资源中包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把它们都放到进程中可以更容易管理。 另一个概念是进程拥有一个可以执行的线程，简称为线程。在线程中有一个程序计数器，用来记录接着要执行哪一条指令。线程拥有寄存器，用来保存线程当前的工作变量。线程还拥有一个堆栈用来记录执行历史，其中每一帧保存了一个已调用的但是还没有从中返回的的过程。 尽管线程必须在某个进程中执行，但是线程和它的进程是不同的概念，并且可以分别处理。进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 在同一个线程中并行运行多个进程，是对在同一台计算机上并行运行多个进程的模拟。在前一种情形下，多个线程共享同一个地址空间和其他资源。而在后一种情形中，多个进程共享物理内存、磁盘打印机和其他资源。 由于线程具有进程的某些性质，所以有时被称为“轻量级进程”。 在下图a中可以看到三个传统的进程。每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行。在图b中，可以看到一个进程带有三个控制线程。这三个线程全部在相同的地址空间中运行。 进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一致的地址空间，这就意味着他们也共享同样的全局变量。由于各个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写或甚至清除另一个线程的堆栈。线程之间是没有保护的。原因是：1）不可能 2）也没有必要 。这与不同进程是有差别的。不同的进程会来自不同的用户，它们彼此之间可能有敌意，一个进程总是由某个用户所拥有该用户创建多个线程应该是为了它们之间的合作而不是彼此间争斗。除了共享地址空间外，所有线程还共享同一个打开文件集、子进程、定时器以及相关信号等。 在下图中：第一列给出了在一个进程中所有线程共享的内容，第二列给出了每个线程自己的内容。 线程概念试图实现的是，共享一组资源的的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作。 和传统进程一样（即只有一个线程的进程），线程可以出于若干种状态的任何一个：运行、阻塞、就绪或终止。线程之间的转换和进程之间的转换是一样的。 每个线程都有其自己的堆栈，如上图所示。每个线程的堆栈中有一帧，供各个被调用但是还没有从中返回的过程使用。在该栈帧中存放了相应过程的局部变量以及过程调用完成之后使用的返回地址。 通常每个线程会调用不同的过程，从而有一个各自不同的执行历史，这就是为什么每个线程需要有自己的堆栈的原因。 线程的创建： 在多线程的情况下，进程通常会从当前的单个线程开始。这个线程有能力通过调用一个库函数（如thread_create）创建新的线程。thread_create的参数专门指定了新线程要运行的过程名。这里没有必要对新线程的地址空间加以规定，因为新线程会自动在创建线程的地址空间中运行。有时线程是有层次的，它们具有一种父子关系，但是通常不存在这样一种关系，所有的线程都是平等的。不论有无层次关系，创建线程通常都返回一个线程标识符，该标识符就是新线程的名字。 线程的终止： 当一个线程完成工作后，可以通过调用一个库过程（如thread_exit）退出，该进程接着消失，不再可调度。在某些线程系统中，通过调用一个过程(如：thread_join)一个线程可以等待一个特定的线程退出。这个过程阻塞调用线程直到那个特定线程退出。 thread_yield：另一个常见的线程调用是thread_yield，它允许线程自动放弃CPU从而让另一个线程运行。这样一个调用是很重要的，因为不同于进程，（线程库）无法利用时针中断强制线程让出CPU，所以设法使线程行为高尚起来并且随着时间的推移自动交出CPU，以便让其他进程有机会运行，就变得非常重要。有的调用允许某个线程等待另一个线程完成某些任务，或等待一个线程宣称它已经完成了有关的工作等。 线程所带来的一些问题：1）.如果父进程拥有多个线程，那么它的子进程也应该拥有这些线程吗？如果不是，则该子进程可能会工作不正常，因为在该子进程中的线程都是绝对必要的。2）.如果子进程拥有了与父进程一样多的线程，如果父进程在read调用上被阻塞了会发生什么情况？3）.还有一类问题和线程共享许多数据结构的事实有关等 POSIX线程 IEEE定义的线程包叫做pthread。大部分UNIX系统都支持该标准。这个标准定义了超过60个系统调用。所有pthread线程都有某些特性。每个都含有一个标识符、一组寄存器（包括 程序计数器）和一组存储在结构中的属性。这些属性包括堆栈大小、调度参数以及其他线程需要的项目。 线程调用 描述 pthread_create 常见一个新线程 pthread_exit 结束调用的线程 pthread_join 等待一个特定的线程退出 pthread_yield 释放CPU来运行另一个线程 pthread_attr_init 创建并初始化一个线程的属性结构 pthread_attr_destory 删除一个线程的属性结构 一些pthread的函数调用 创建一个新线程需要使用pthread_create调用。新创建的线程的线程标识符会作为函数值返回。这种调用有意看起来很像fork系统调用，其中线程标识符起着PID的作用，而这么做的目的主要是为了标识在其他调用中引用的线程。 当一个线程完成分配给它的工作后，可以通过调用pthread_exit来终止，这个调用终止线程并释放它的栈。 像pthread_join、pthread_yield的作用前面已经介绍了。 最下面的两个线程调用是处理属性的。pthread_attr_init建立关联一个线程的属性结构并初始化成默认值。这些值（例如优先级）可以通过修改属性结构中的域值来改变。 pthread_attr_destory删除一个线程的属性结构，释放它占用的内存。它不会影响调用它的线程。这些线程会继续存在。 为了更好地了解pthread是如何工作的，考虑下面的例子。 #include&lt;pthread.h&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define NUMBER_OF_THREADS 10 void *print_hello_world(void *tid) { /*本函数输出线程的标识符，然后退出。 */ printf(&quot;Hello World.Greetings from thread %d\\n&quot;,tid); pthread_exit(NULL); } int main(int argc,char *argv[]) { /*主程序创建10个线程然后退出。 */ pthread_t threads[NUMBER_OF_THREADS]; int status,i; for(i=0;i&lt;NUMBER_OF_THREADS;i++){ printf(&quot;Main here,Create thread %d\\n&quot;); status = pthread_create(&amp;threads[i],NULL,print_hello_world),(void *)i); if(status != 0){ printf(&quot;Oops.pthread_create returned error code %d\\n&quot;,status); exit(-1); } } exit(NULL); } 这里主程序在宣布它的意图之后，循环NUMBER_OF_THREADS次，每次创建一个新的线程。如果线程创建失败，会打印出一条错误信息然后退出。在创建完所有线程之后，主程序退出。当创建一个线程时，它打印一条一行的发布信息，然后退出。这些不同信息交错的顺序是不确定的并且可能在连续运行程序的情况下发生变化。 在用户空间中实现线程 把整个线程包放在用户空间中，内核对线程一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程。（即进程表在内核中，线程表在用户空间中。） 在用户空间中实现线程的优点： （1）.用户级线程包可以在不支持线程的操作系统上实现。通过这一方法，可以使用函数库实现线程。所有的这类实现都有同样的通用结构。如图一（a）所示，线程在一个运行时系统的上层运行，该运行时系统是一个管理线程的过程的集合。 在用户管理线程时每个进程需要有其专用的线程表，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它们仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态等。该线程表由运行时系统管理，当一个线程转换到就绪状态或阻塞状态时，在该线程表中存放重新启动该线程所需的信息，与内核在进程表中存放进程的信息完全一样。（2）.进行类似于这样的线程切换至少比陷入内核要快一个数量级（或许更多），这是使用用户级线程包的极大的优点。（3）.保存该线程状态的过程和调度程序都只是本地过程，所以启动它们比进行内核调用效率更高。（4）.不需要陷入内核，不需要上下文切换，也不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷。（5）.它允许每个线程有自己的调度算法。（6）.具有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果内核线程的数量非常大，就会出现问题。 在用户空间中实现线程的问题： （1）.如何实现阻塞调用使用线程的一个主要目标是，首先要允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有了阻塞系统调用，这个目标不是轻易能够实现的。对于上述问题的解决：1. 系统调用可以全部改成非阻塞的，但是这需要修改操作系统 2. 如果某个调用会阻塞，就会提前通知。其过程为首先进行select调用，然后只有在安全的情形下（即不会阻塞）才进行read调用。如果read调用会被阻塞，有关的调用就不进行，代之运行另一个线程。到了下次有关的运行系统取得控制权之后，就可以再次检查看看现在进行read调用是否安全。在系统调用周围从事检查的这类代码称为包装器。（2）.缺页中断问题，如果某个程序调用或者跳转到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令（和该指令的“邻居们 ”），这就称为“页面故障”。（3）.如果一个线程开始运行那么在该进程中的其他线程就不能运行，除非第一个线程自动调用CPU。其可能的解决方案是：让运行时系统请求每秒一次的时钟信号（中断），但是这样对程序是生硬的和无序的。不可能总是高频率地发生周期性的时钟中断，即使可能总的开销也是可观的。而且线程也可能需要时钟中断，这就会扰乱运行时系统使用的时钟。（4）.程序员通常在经常发生线程阻塞的应用中才希望使用多个线程。对于那些基本上是CPU密集型（一些进程绝大多数时间在计算上，称为计算密集型（也称CPU密集型））而且极少有阻塞的应用程序而言，就没必要使用多线程了。 在内核中实现线程 不需要运行时系统，而且每个进程中也没有线程表。在内核中有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它进行一个系统调用，这个系统调用通过对线程表的更新完成线程创建或撤销工作。（即进程表和线程表都在内核中）如图一（b）所示。 （1）.所有能够阻塞线程的操作都以系统调用的形式实现，这与运行时系统过程相比，代价是相当客观的。当一个线程阻塞时，内核根据其选择，可以运行同一个进程中的另一个线程（若有一个就绪的线程）或者运行另一个进程的线程。而在用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU（或者没有可运行的线程存在了）为止。（2）.在内核中创建或撤销线程的代价比较大。可以采用回收线程的方法解决：当某个线程被撤销时，就把它标识为不可运行，但是其内核数据没有受到影响。稍后再创建一个新线程时，就重新启动某个旧线程，从而节省开销。（3）.内核线程不需要任何新的、非阻塞系统调用。这样做的缺点是系统调用的代价比较大，所以如果线程的操作（创建、终止等）比较多，就会造成很大的开销。 使用内核线程带来的问题：1. 当一个多线程进程创建新的进程时会发生什么？ 2. 如果两个或多个线程注册了相同的信号，会发生什么？ 等等。 混合实现一种方法是使用内核级线程，然后将用户级线程与某些或者全部内核线程多路复用起来。如下图所示。 优点：编程人员可以决定用多少个内核级线程和多少个用户级线程彼此多路复用。这一模型带来最大的灵活度。 采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。如同在没有多线程能力操作系统中某个进程中的用户级线程一样，可以创建、撤销和调度这些用户级线程。在这种模型中，每个内核级线程有一个可以轮流使用的用户级线程集合。 调度程序激活机制 调度程序激活工作的目标是模拟内核线程的功能，但是为线程包提供通常在用户空间中才能实现的更好的性能和更大的灵活性。特别地，如果用户线程从事某种系统调用时是安全的，那就不应该进行专门的非阻塞调用或者进行提前检查。无论如何，如果线程阻塞在某个系统调用或页面故障上，只要在同一个进程中有任何就绪的线程，就应该有可能运行其他的线程。 由于其避免了在用户空间和内核空间之间的不必要转换，从而提高了效率。 当时使用调度程序激活机制时，内核给每个进程安排一定数量的虚拟处理器，并让（用户空间）运行时系统将线程分配到处理器上。这一机制也可以用在多处理器中，此时虚拟处理器可能成为真实的CPU。分配给一个进程的虚拟处理器的初始数量是一个，但是该进程可以申请更多的处理器并且在不用时退回。 使该机制工作的基本思路是当内核了解到一个线程被阻塞之后（例如由于执行了一个阻塞系统调用或者产生了一个页面故障），内核通知该进程的运行时系统，并且在堆栈中以参数形式传递有问题的线程编号和所发生事件的一个描述。内核通过在一个已知的起始地址启动运行时系统，从而发出了通知，这是对UNIX中信号的一种粗略模拟。这个机制称为上行调用。 调度程序激活机制的一个目标是作为上行调用的信赖基础，这是一种违反分层次系统内在结构的概念。通常，n层提供n+1层可调用的特定服务，但是n层不能调用n+1层中的过程。上行调用并不遵守这个基本原理。 弹出式线程 一个消息的到达导致系统创建一个处理该消息的线程，这种线程称为弹出式线程。 弹出式线程的关键好处是：由于这种线程相当新，没有历史————没有必须储存的寄存器、堆栈诸如此类的内容，每个线程从全新开始，每一个线程彼此之间都完全一样。这样，就有可能快速创建这类线程。对该新线程指定所要处理的信息。使用弹出式线程的结果是，消息到达与处理开始之间的时间非常短。 在使用弹出式线程之前，需要提前进行计划。例如：哪个进程中的线程先运行？如果系统支持在内核上下文中运行线程，线程就有可能在那里运行（这就是下图中没有画出内核的原因。） 优点： 在内核空间中运行弹出式线程通常比在用户空间中容易且快捷，而且内核空间中的弹出式线程可以很容易访问所有的表格和I/O设备。这也许在中断处理时有用。 缺点： 出错的内核线程会比出错的用户线程造成更大的损害。例如，如果某个线程运行时间太长，又没有办法抢占它，就可能造成进来的信息丢失。 使单线程代码多线程化 许多已有的程序是为单线程进程编写的。把这些程序改写成多线程需要比直接写多线程程序更高的技巧。考虑一个例子，考虑由UNIX维护的errno变量。当进程或（线程）进行系统调用失败时，错误码会放入errno。在下图中，线程1执行系统调用access以确定是否允许它访问某个特定文件。操作系统把返回值放到全局变量errno中。当控制权返回到线程1之后，并在线程1读取errno之前，调度程序确认线程1此刻已用完CPU时间，并决定切换到线程2.线程2执行一个open调用，结果失败，导致重写errno，于是给线程1的返回值会永远丢失。随后在线程1执行时，它将读取错误的返回值并导致错误操作。 对于上面问题已有各种解决方案。（1）全面禁止全局变量，但它同许多已有的软件冲突。（2）为每个线程赋予其私有的全局变量如下图所示：在这个方案中，每个线程有自己的errno以及其他全局变量的私有副本，这样就避免了冲突。在效果上，这个个方案创建了新的作用域层，这些变量对一个线程中所有过程都是可见的。而在原先的作用层域中变量值对一个过程可见，并在程序中处处可见。（3）引入新的库过程，以便创建、设置和读取这些线程范围的全局变量。首先一个调用也许是这样的：create_global(“bufptr”);该调用在堆上或在专门为调用线程所保留的特殊存储区上替一个名为bufptr的指针分配存储空间。无论该存储空间分配在何处，只有调用线程才可访问其全局变量。如果另一个线程创建了同名的全局变量，由于他在不同的存储单元上，所以不会与已有的那个变量产生冲突。（4）为每个过程提供一个包装器，该包装器设置一个二进制位从而标志某个库处于使用中。在先前的调用还没有完成之前，任何试图使用该库的其他线程都会被阻塞。尽管这个方式可以工作，但是它会极大地降低系统潜在的并行性。","categories":[{"name":"现代操作系统学习","slug":"现代操作系统学习","permalink":"https://tannisi.top/categories/现代操作系统学习/"}],"tags":[{"name":"进程与线程","slug":"进程与线程","permalink":"https://tannisi.top/tags/进程与线程/"}]},{"title":"进程与线程（一）","slug":"进程与线程（一）","date":"2018-01-26T04:13:01.000Z","updated":"2018-01-27T10:31:41.777Z","comments":true,"path":"2018/01/26/进程与线程（一）/","link":"","permalink":"https://tannisi.top/2018/01/26/进程与线程（一）/","excerpt":"操作系统中最核心的概念是进程：这是对正在运行程序的一个抽象。操作系统的其他所有内容都是围绕着进程的概念展开的。 即使可以使用的CPU只有一个，但他们也具有支持（伪）并发操作的能力，它们将一个单独的CPU变换成多个虚拟的CPU。可以说：没有进程的抽象，现代计算将不复存在。","text":"操作系统中最核心的概念是进程：这是对正在运行程序的一个抽象。操作系统的其他所有内容都是围绕着进程的概念展开的。 即使可以使用的CPU只有一个，但他们也具有支持（伪）并发操作的能力，它们将一个单独的CPU变换成多个虚拟的CPU。可以说：没有进程的抽象，现代计算将不复存在。 进程 在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。严格地说，在某一个瞬间，CPU只能运行一个进程。但在一秒钟内，它可能运行多个进程，这样就产生并行的错觉。有时人们所说的伪并行就是指这种情形，以此来区分多处理器系统（该系统有两个或多个CPU共享一个物理内存）的真正硬件并行。 进程模型 在进程模型中，所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称“进程”。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说，每个进程有它自己的虚拟CPU。当然实际上真正的CPU在各个进程之间来回切换。这种快速切换，被称为多道程序设计。 在下图（a）中可以看到，在一台多道程序计算机的内存中有四道程序。在下图（b）中，这4道程序被抽象为4个各自拥有自己控制流程（即每个程序自己的逻辑程序计数器）的进程，并且每个程序都独立地运行。当然实际上只有一个物理程序计数器，所以在每个程序运行时，它的逻辑程序计数器被装入实际的程序计数器中。当该程序执行结束（或暂停执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。在下图c中可以看到，在观察足够长的一顿时间后，所有的程序都运行了，但在任何一个给定的瞬间仅有一个进程真正在运行。 由于CPU在各进程之间来回快速切换，所以每个进程执行器运算的速度是不确定的。而且当同一进程再次运行时，其运算速度通常不可再现。所以在对进程编程时决不能对时序做任何想当然的假设。然而，通常大多数进程并不受CPU多道程序设计或其它进程相对速度的影响。 进程和程序间的区别是非常微妙的，但非常重要。用一个比喻可以很容易理解这一点：想象有一位计算机科学家在位他的女儿烘制蛋糕。他有做生日蛋糕的食谱，厨房里有所需要的原料。则做蛋糕的食谱就是程序（即用适当形式描述的算法），计算机科学家就是CPU，厨房里的原料就是输入数据。进程就是厨师阅读食谱、取来原料以及烘制蛋糕等一系列动作的综合。 关键思想：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。 值得注意的是,如果一个程序运行了两遍，则算作两个进程。 进程的创建 在通用操作系统中，需要有某种方法在运行时按需要创建或撤销进程，现在开始考察这个问题。 4种主要事件会导致进程的创建：（1）系统初始化（2）正在运行的程序执行了创建进程的系统调用（3）用户请求创建一个新的进程（4）一个批处理作业的初始化 启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户（人类）交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，相反却具有某些专门的功能。停留在后台处理诸如电子邮件、web页面、新闻、打印之类的活动的进程称为守护进程。在大型系统中有很多守护进程。在UNIX中，可以用ps程序列出正在运行的进程；在Windows中，可使用任务管理器。 一个正在运行的进程经常发出系统调用，以便创建一个或多个新进程协助其工作。在所要从事的工作可以很容易的划分出成个若干相关的但没有相互作用的进程时，创建新的进程就特别有效果。 在交互式系统中，键入一个命令或点击一个图标就可以启动一个程序。这两个动作中的任何一个都会创建一个新的进程，并在其中运行所选择的程序。在基于命令行的UNIX系统中运行程序X，新的进程会从该进程接管它的窗口。 最后一种创建进程的情形仅在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。在操作系统认为有资源可运行另一个作业时，它会创建一个新的进程，并运行其输入队列中的下一个作业。从技术上看，在以上所有的情形中，新进程都是由于一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程所做的工作是，执行一个用来创建进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序。在UNIX系统中，只有一个系统调用可以用来创建新的进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用了fork之后，这两个进程（父进程和子进程）拥有相同的内存映像、同样的环境字符串和同样的打开文件。这就是全部情形。通常子进程接着执行execve或一个类似的系统调用，已修改其内存映像并运行一个新的程序。之所以要安排两步建立进程，是为了在fork之后但在execve之前允许该子进程处理描述其文件描述符，这样就可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。在Windows中情形正好相反，一个Win32函数调用CreateProcess（该调用有10个参数）既处理进程的创建，也负责把正确的程序装入新的进程。除了CreatProcess，Win32中有大约100个其他的函数用于处理进程的管理、同步以及相关的事务。在UNIX和Windows中，进程创建之后，父进程和子进程各拥有不同的地址空间。如果其中某个进程在地址空间中修改了一个字，这个修改对其他进程而言是不可见的。在UNIX中，子进程的初始地址空间是个父进程的一个副本，但是这里涉及两个不同的地址空间，不可写的内存区是共享的。某些UNIX的实现使程序正文在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但这种情况先内存通过写实复制共享，这意味着一旦两者之一想要修改部分内存 ，则这块内存首先被明确地复制，以确保修改发生在私有内存区域。再次强调，可写的内存是不可以共享的。但是对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，例如打开的文件等。在Windows中，从一开始父进程的地址空间和子进程的地址空间就不同。进程的终止新的进程的终止，通常由下列条件引起：（1）正常退出（自愿的）（2）出错退出（自愿的）（3）严重错误（非自愿的）（4）被其他进程杀死（非自愿的） 多数进程是由于完成了它们的工作而终止。当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成。在UNIX中该调用是exit，而在Windows中，相关的调用是ExitProcess。 第二个原因是：进程发现了严重错误。在给出了错误参数时，面向屏幕的交互进程通常并不退出。相反，这些程序会弹出一个对话框，并要求用户再试一次。 第三个原因：由进程引起的错误，通常是由于程序中的错误所致。例如执行了一条非法指令、引用不存在的内存、除数为0等。有些系统中（如UNIX），进程可以通知操作系统，它希望自行处理某些类型的错误，在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。 第四个原因：某个进程执行一个系统调用通知操作系统杀死某个其他的进程。在UNIX中这个系统调用是kill，在Win32中对应的函数是TerminateProcess。在这两种情形中，“杀手”都必须获得确定的授权以便进行动作。（在Linux中一般要赋予root权限，才能执行kill操作）进程的层次结构某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。进程只有一个父进程，但是可以有零个、一个、两个或多个子进程。在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。考虑UNIX系统在启动时如何初始化自己。一个称为init的特殊进程出现在启动映像中，当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登陆进程就执行一个shell准备接收命令。所接收的命令会启动更多的进程，以此类推，这样整个系统中，所有的进程都属于以init为根的一棵树。相反，在Windows中没有进程层次的概念，所有的进程地位都是相同的。唯一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌（称为句柄）,该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他的进程，这样就不存在进程层次了。在UNIX中，进程就不能剥夺其子进程的“继承权”。进程的状态尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。当一个进程在逻辑上不能继续运行时，他就会被阻塞，典型的例子是它在等待可以使用的输入。还可能有这样的情况：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。这两种情况是完全不同的。在第一种情况下，进程挂起是程序固有的原因（在键入用户命令行之前，无法执行命令）。第二种情况则是由于系统技术上的原因引起的（由于没有足够的CPU，所以不能使每个进程都有一台私用的处理器）。在图1中可以看到显示进程的三种状态的状态图，这三种状态是：（1）运行态（该时刻进程实际占用CPU）（2）就绪态（可运行，但因为其它进程正在运行而暂时停止）（3）阻塞态（除非某种外部事件发生，否则进程无法运行）。 进程的三种状态之间有四种可能的转换关系。如图1所示。在操作系统发现进程不能运行下去时，发生转换1。在某些系统中，进程可以执行一个诸如pause的系统调用来进入阻塞状态。 转换2和3是由进程调度程序引起的，进程调度程序是操作系统的一部分，进程甚至感觉不到调度程序的存在。系统认为一个运行进程占用处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2.在系统已经让所有其他进程享有了他们应当应有的公平待遇而重新轮到第一个进程再次占用CPU时间时，会发生转换3。 当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4.如果此时没有其他进程运行，则立即触发转换3，该进程便开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行。调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间，这是很重要的一点。进程的实现为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表。每个进程表占用一个进程表项。（有时也称进程控制块）该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。图2展示了在一个典型系统中的关键字段。与每一I/O类关联的是一个称作中断向量的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入栈堆，计算机随机跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是终端服务例程就接管一切剩余的工作。所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作，无法用C语言这一类高级语言来描述，所以这些操作通常通过一个短小的汇编语言里程来完成，通常该例程可以供所有的中断来完成，因为无论中端是怎样引起的，有关保存寄存器的工作则是完全一样的。当该例程结束后，它调用一个C过程处理处理某个特定的中断类型剩下的工作。在完成有关工作之后，大概就会使某些进程就绪接着调用调度程序，决定随后该运行哪个进程。随后将控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行。多道程序设计模型采用多道程序设计可以提高CPU的利用率。严格的说，如果进程用于计算的平均时间是进程在内存中停留时间的20%，且内存中同时有5个进程，则CPU将一直满负载运行。然而，整个模型在现实中过于乐观，因为它假设这5个进程不会同时等待I/O。更好的模型是从概率的角度来看CPU的利用率。假设一个进程等待I/O操作的时间与其停留在内存中的时间比为p。当内存中同时有n个进程时，则所有n个进程都在I/O的概率是Pn（幂指数）。CPU的利用率由下面的公式给出：CPU利用率 = 1-Pn图3以n为变量的函数表示了CPU的利用率，n称为多道程序设计的道数。如果进程花费80%的时间等待I/O，为使CPU的浪费低于10%，至少要有10个进程同时存在内存中。进程不是独立的。更精确的模型应该由排队论构建，但我们的模型（当进程就绪时，给进程分配CPU，否则让CPU空转）仍然是有效的，即使真实曲线会与图3略有不同。图3对预测cpu的性能很有效。例如：假设计算机有8GB的内存，操作系统及相关表格占用2GB，每个用户程序也占用2GB。这些内存空间允许3个用户程序同时驻留在内存中。若80%的时间用于I/O等待，这CPU的利用率大约是1-(0.80.80.8),即大约是49%.在增加8GB的内存后可从3道程序设计提高到7道程序设计，此时CPU的利用率提高到79%。提高了30%的吞吐量。增加第三个8GB的内存，CPU的利用率提高到91%，吞吐量的提高仅为12%.则第二次增加内存是不划算的。因此，盲目提高内存，有时提高不了多少性能，它还与系统等待I/O的时间、CPU的性能有关。","categories":[{"name":"现代操作系统学习","slug":"现代操作系统学习","permalink":"https://tannisi.top/categories/现代操作系统学习/"}],"tags":[{"name":"进程与线程","slug":"进程与线程","permalink":"https://tannisi.top/tags/进程与线程/"}]},{"title":"现代操作系统学习小结","slug":"现代操作系统学习小结","date":"2018-01-26T04:08:18.000Z","updated":"2018-01-26T05:14:08.418Z","comments":true,"path":"2018/01/26/现代操作系统学习小结/","link":"","permalink":"https://tannisi.top/2018/01/26/现代操作系统学习小结/","excerpt":"引论（1）考察操作系统有两种观点：资源管理观点和扩展的机器观点。在资源管理观点中，操作系统的任务是有效的管理系统的各个部分。在扩展的机器观点中，系统的任务是为用户提供比实际机器更便于运用的抽象。这些抽象包括进程、地址空间以及文件。（2）操作系统的历史很长，从操作系统开始替代操作人员的那天开始到现代多道程序系统，主要包括早期批处理系统、多道程序系统以及个人计算机系统。","text":"引论（1）考察操作系统有两种观点：资源管理观点和扩展的机器观点。在资源管理观点中，操作系统的任务是有效的管理系统的各个部分。在扩展的机器观点中，系统的任务是为用户提供比实际机器更便于运用的抽象。这些抽象包括进程、地址空间以及文件。（2）操作系统的历史很长，从操作系统开始替代操作人员的那天开始到现代多道程序系统，主要包括早期批处理系统、多道程序系统以及个人计算机系统。（3）所有操作系统构建所依赖的基本概念是进程、存储管理、I/O管理、文件管理和安全。（4）任何操作系统的核心是它可处理的系统调用集。这些系统调用真实的说明了操作系统所做的工作。对于UNIX，我们已经考察了四组系统调用。第一组系统调用同进程的创建和终止有关，第二组用于读写文件，第三组用于目录管理，第四组用于各种杂项调用。（5）操作系统的构建方式有多种，最常见的有单体系统、层次化系统、微内核系统、客户端-服务器系统、虚拟机系统以及外核系统。","categories":[{"name":"现代操作系统学习","slug":"现代操作系统学习","permalink":"https://tannisi.top/categories/现代操作系统学习/"}],"tags":[{"name":"操作系统学习小结","slug":"操作系统学习小结","permalink":"https://tannisi.top/tags/操作系统学习小结/"}]},{"title":"依靠C的世界——编写操作系统","slug":"依靠C的世界——编写操作系统","date":"2018-01-25T12:33:26.000Z","updated":"2018-01-26T04:05:41.249Z","comments":true,"path":"2018/01/25/依靠C的世界——编写操作系统/","link":"","permalink":"https://tannisi.top/2018/01/25/依靠C的世界——编写操作系统/","excerpt":"操作系统通常是由许多程序员写成的，包括很多部分的大型C（有时是C++）程序。 C语言 在C中基本数据类型是整数（包括短整数和长整数）、字符和浮点数等。使用数组、结构体和联合，可以构造组合数据类型。C语言中的控制语句与Java类似，包括if、、switch、for以及while等语句。在这两个语言中，函数和参数大致相同。","text":"操作系统通常是由许多程序员写成的，包括很多部分的大型C（有时是C++）程序。 C语言 在C中基本数据类型是整数（包括短整数和长整数）、字符和浮点数等。使用数组、结构体和联合，可以构造组合数据类型。C语言中的控制语句与Java类似，包括if、、switch、for以及while等语句。在这两个语言中，函数和参数大致相同。 一项C语言中有而Java和Python中没有的特点是显式指针。指针是一种指向（即包含对象的地址）一个变量或数据结构的变量。C语言中没有内建字符串、线程、包、类、对象、类型安全以及垃圾回收等。最后一个是操作系统的“淋浴器塞子”。在C中分配的存储空间或者是静态的，或者是程序员明确分配和释放的，通常使用malloc以及free库函数。正是由于后面的这个性质——由程序员控制所有内存——而且是明确的指针，使得C语言対编写操作程序而言非常有吸引力。从一定程度上来说，操作系统实际上是一个实时操作系统，甚至通用系统也是实时系统。当中断发生时，操作系统可能只有若干微秒去完成特定的操作，否则会丢失关键的信息。在任意时刻启动垃圾回收功能是不可接受的。 头文件 一个操作系统项目通常包括多个目录，每个目录都含有许多.c文件，这些文件中存有系统某个部分的代码，而一些.h头文件则包含供一个或多个代码文件使用的声明及定义。头文件还可以包含简单的宏，宏允许程序员命名常数宏可以附带参数。头文件汉可以包含条件编译，例如： #ifdef X86 intel_int_ack(); #endif 如果宏X86有定义，而不是其他，则编译进对Intel_int_ack函数的调用。为了分隔与结构有关的代码，大量使用了条件编译，这样只有当系统在X86上编译时，一些特定的代码才会被插入，其他的代码仅当系统在SPARC等机器上编译时才会插入。通过使用#include指令，一个.c文件体可以含有一个或多个头文件。 大型编程项目 为了构建操作系统，每个.c被C编译器编译成一个目标文件。目标文件使用后缀.o，含有目标机器的二进制代码。随后它们可以直接在CPU上运行。在C的世界里，没有类似于Java字节代码的东西。 补充：（Java 字节码（英语：Java bytecode）是Java虚拟机执行的一种指令格式。大多数操作码都是一个字节长，而有些操作需要参数，导致了有一些多字节的操作码。而且并不是所有可能的256个操作码都被使用；其中有51个操作码被保留做将来使用。除此之外，原始Java平台开发商，Sun Microsystems系统，额外保留了3个代码永久不使用。） C预处理器+C编译器 C编译器的第一道称为C预处理器。在它读入每个.C文件时，每当遇到一个#include命令，就取来该名称的头文件，并加以处理、扩展宏、处理条件编译（以及其他事务），然后将结果传递给编译器的下一道，仿佛它们原先就包含在该文件中一样。 make程序 由于操作系统是非常庞大的，每当文件修改后就重新编译时无法忍受的。另一方面，改变了用在成千上万文件中的一个关键头文件，确实需要重新编译这些文件。没有一定的协助，想要记录哪个目标文件和哪个头文件相关是完全不可行的。 在UNIX系统中，有个名为make的程序，它读入Makefile文件，该Makefile说明哪个文件与哪个文件相关。make的作用是，在构建操作系统二进制编码时，检查此刻需要哪个目标文件，而且对于每个文件，检查自从上次目标文件创建之后是否有任何它依赖的文件（代码和头文件）已经被修改了。如果有，目标文件需要重新编译。在make确定了哪个.o文件需要重新编译后，他调用C编译器重新编译这些文件，这样就把编译的次数降到了最低限度！ linker程序形成可执行文件a.out文件 一旦所有的.o文件就绪，这些文件就被传递给称为linker的程序，将其组合成一个可执行的二进制文件。此时，任何被调用的库函数到包含在内，函数之间的引用都已解决，而机器地址也已经按需分配完毕。在linker完成之后，得到一个可执行程序，在UNIX中传统上称为a.out文件。该过程的各个部分如下图所示： 运行模型 在操作系统二进制代码链接完成后，计算机就可以重新启动，新的操作系统开始运行。一旦运行，系统会自动调入那些没有静态包括在二进制代码中的模块，如设备驱动和文件系统。在运行过程中，操作系统可能有若干段组成，有文本段(程序代码)、数据段和栈堆段。文本段通常是不可改变的，在运行过程中不可修改。数据段开始时有一定的大小，并用确定的值进行初始化，但是随后就被修改了，其大小随需要增长。栈堆段被初始化为空，但是随着对函数的调用和从函数返回，栈堆段时时刻刻在增长和缩小。通常文本段放置在接近内存底部的位置，数据段在其上面，这样可以向上增长。而栈堆段处于高处的虚拟地址，具有向下增长的能力，不过不同系统的工作方式各有差别。 在所有情形下，操作系统代码都是直接在硬件上执行的，不用解释器，也不是即时翻译，如Java通常做的那样。 ACM https://www.acm.org/IEEE计算机协会 https://www.computer.org/USENIX https://www.usenix.org/","categories":[{"name":"现代操作系统学习","slug":"现代操作系统学习","permalink":"https://tannisi.top/categories/现代操作系统学习/"}],"tags":[{"name":"简介编写操作系统的环境","slug":"简介编写操作系统的环境","permalink":"https://tannisi.top/tags/简介编写操作系统的环境/"}]},{"title":"计算机网络原理和因特网","slug":"计算机网络原理和因特网","date":"2018-01-23T06:32:33.000Z","updated":"2018-01-23T06:50:45.799Z","comments":true,"path":"2018/01/23/计算机网络原理和因特网/","link":"","permalink":"https://tannisi.top/2018/01/23/计算机网络原理和因特网/","excerpt":"一、计算机网络定义1.计算机网络的五大基本元素（1）主机（用户终端、服务器）（2）交换节点 （3）通信链路 （4）拓扑结构 （5）通信软件2.计算机网络的公共特性（1）覆盖范围 ：按网络覆盖地理范围大小加以区分（2）传输方式 ：按网络传输数据方式加以区分（3）交换技术 ：按网络交换数据技术加以区分 二、计算机网络分类概述1.按网络覆盖范围分类个域网、局域网、城域网、广域网2.按网络传输技术分类广播发送、点-点传播（复杂性较高）3.按数据交换技术分类（数据交换效率越来越高）电路交换（电话）、包交换（计算机网络）4.按传输介质分类（信道访问技术越来越难）有线网络、无线网络","text":"一、计算机网络定义1.计算机网络的五大基本元素（1）主机（用户终端、服务器）（2）交换节点 （3）通信链路 （4）拓扑结构 （5）通信软件2.计算机网络的公共特性（1）覆盖范围 ：按网络覆盖地理范围大小加以区分（2）传输方式 ：按网络传输数据方式加以区分（3）交换技术 ：按网络交换数据技术加以区分 二、计算机网络分类概述1.按网络覆盖范围分类个域网、局域网、城域网、广域网2.按网络传输技术分类广播发送、点-点传播（复杂性较高）3.按数据交换技术分类（数据交换效率越来越高）电路交换（电话）、包交换（计算机网络）4.按传输介质分类（信道访问技术越来越难）有线网络、无线网络 三、基于网络覆盖范围的分类1.个域网（PAN）：覆盖的地理范围通常围绕着一个人通信用的设备（如无线键盘、无线鼠标等）（可用蓝牙来组网）。2.局域网（LAN）：覆盖的地理范围通常为一个办公室、一个楼层、一座建筑物（组网方式：所有主机都连接在一个网络专用设备（如集线器等），以竞争的方式使用信道）2.1局域网络——无线局域网（WLAN）：通常用在一个办公区域、家居环境、机场、车站等公共区域（一般用WiFi）。无线局域网中（WiFi）的组网方式：所有用户终端通过无线介质连接到一个提供无线接入功能的高性能基站3.城域网（MAN）：覆盖的地理范围通常为一座城市。（组网方式：用户终端通过无线介质连接到一个提供无线接入功能的高性能基站）（一般采用“全球微波互联技术”）4.广域网（WAN）：覆盖的地理范围非常大，可达数百公里或数千公里。组网方式：节点之间通过点-点链路连接成一定拓扑结构的网状形式。 四、基于网络传输技术的分类1.广播网络：广播网络只有一个通信信道（共享介质）。网络上所有的主机/节点共享该信道进行数据通信。（一般有三种方式：单播、广播、组播）一般用总线型结构来表示。介质访问控制（MAC）：负责共享信道带宽的分配和管理。（有两种分配模式：静态分配和动态分配）静态分布：固定分配模式、控制算法简单、资源利用率低动态分布：按需分配模式、控制算法复杂、资源利用率高2.点-点网络————拓扑结构：由许多一对对计算机之间的链路组成。拓扑结构：指计算机网络的物理布局。分为：星型、环型、树型、全连通也有三种模式：点-点单播、点-点广播、点-点组播点-点网络——多跳传输：指信息的传递需要借助其恰当的其他节点辅助才能完成传输。3.（1）小型、地理位置集中的网络多采用广播形式 （2）大型、地理位置分散的网络多采用点到点方式 五、计算机网络的一般形式1.因特网一般形式2.课程展开的主要内容（1）.计算机网络的核心技术（2）.接入网有哪些技术（3）.在同一网络中主机通信（4）.在不同网络中主机通信（5）.在不同主机上进程通信（6）.网络服务/安全怎么做3.在TCP/IP网络体系结构下，自底向上位于第二层的是：网络层 六、电话网络与电路交换1.什么是交换？交换过程：把主叫方的电话线与被叫方的电话线用跳线电缆连接起来的过程。特点：（1）.主叫方和被叫方必须建立一条专用电路 （2）.在通信期间该电路保持连接并不为他人用2.电话系统的扩展性（如两个城市之间的电话通信）（1）.当网络规模增大时通常采用层次型管理模式。（2）.电话接通时间取决于主叫和被叫的距离和途径交换局数目。3.实例：采用电路交换技术假设：（1）.H1给H6发送查毒为7.5Mbits的文件 （2）.建立电路需要10秒；忽略传播延迟试问：将文件从H1传输到H6需多长时间？解:H1发送文件所需时间=7.5/1.5=5s 传输该文件所需的总时间=连接建立时间+发送文件时间=15s4.电路交换技术本质(1).发送方H1按固有的发送频率把文件发送到电路上(2).表示文件的信号沿着电路一路传播到目的地H65.电路交换技术特性优点：实时性好（仅信号传播时延）、稳定的数据传输速率、不存在信道访问延时缺点：不能充分发挥传输介质潜力、长距离电路的建立时间长、扩展性较差（硬件成本） 七、计算机网路与包交换技术1.包交换技术的核心是：存储-转发技术（包/分组：大小固定的数据块）存储-转发：交换节点接受并存储包，然后根据包的目标地址转发该包到通往目的地的出境线路上。2.基于“存储-转发”包交换技术：（1）每个包要指明详细的目的地址（2）交换机根据每个包的目的地址转发 入境线路：报文到达的线路 出境线路：发送报文的线路3.“存储-转发”时延存储转发时延=处理时延（处理时间+发送时间）+排队时延（等待输出的排队时间）4.包交换技术的本质（1）线路上报的顺序是不固定的（2）交换机不必为用户预留资源（3）交换机以及线路等资源按需分配（4）交换机不必记忆每对用户通信状态5.报文与包/分组（1）报文：用户发送的原始数据 包/分组：大小固定的数据块（无完整意义）（2）如果数据报随着用户数据块大小可变：处理时间不确定、小报文的时延大、缓冲区大小无法确定6.实例：采用包交换技术假设：（1）H1给H6发送长度为7.5Mbits的文件（2）包的大小为1500b；忽略传播延迟试问：将文件从H1传播到H6需多长时间？解：第一个包从H1发到S1需要时间1ms 5000ms后最后一个包从H1到达S1 经过三次转发最后一个包到达H6 从H1发送文件到H6总共需要5.003s7.并发传输特性：当第一个包抵达目的地、最后一个包尚未发出时，沿途每个交换机都在并发的传输经过的每个包。8.包交换技术特性优点：（1）将数据分流到不同路径—使得带宽资源利用更加有效（2）若链路出现故障同一个报文剩余包可通过其他路径传送缺点：（1）存储-转发延迟可能会很大（2）排队延迟不确定（与流量成正比）（3）包丢失——报文丢失概率增大 八、电路交换与包交换1.用户电路交换（1）建立电路需要的时间：长短与距离和途径交换机数目有关（2）发送文件需要的时间：长短与文件大小和发送速率有关（3）沿传输介质传播的时间：长短与距离和传输介质有关包交换（1）发送方顺序发送各个包：时间长短与包的大小和发送速率有有关（2）途径交换机“存储-转发”处理：时间长短与处理时延和排队时延有关（3）沿每段传输介质传播：时间长短与该段介质和距离有关2.网络管理者电路交换机针对每对用户的电路建立：（1）确立通往目的地的路径（2）为每条电路预留资源（3）服务用户数受系统容量限制包交换机针对每个包的存储-转发（1）确定通往目的地路径（2）包排入队列等待发送（3）用户数/流量增大影响包传输时间3.包交换与电路交换的系统容量4.计算机网络采用包交换技术（1）包交换机的处理复杂性低（2）包交换系统资源得到有效利用（3）用户数据流可以并发多路径传输电路交换机：任何时候文件只出现在一个地方——串行传输包交换机：文件被分散在每段线路、每个交换机——并行传输 九、评价网络性能的指标1.信道的传输能力传输能力：指传输数据的能力带宽/吞吐量：信号具有的频带宽度，单位是赫（Hz）数据率/比特率：传送数字信号的速率，单位是bps2.（网卡）发送时延/传输时延发送时延：发送时延指的是数据块从第一个比特开始发送算起，到最后一个比特发送完毕所需要的时间。3.信道传播时延传播时延：信号在信道中传播一定距离而花费的时间传播延迟：4.（交换节点）处理/“存储-转发”时延处理/“存储-转发”时延：交换节点为“存储-转发”而进行必要的处理所花费的时间（包的处理、路径的选择、排队等待输出）。发送时延/传输时延：使数据块从节点进入传输介质所需要的时间5.(报文)传输时延时延/延迟：一个报文/包从一个网络（或一条链路）的一端传送到另一端所需要的时间。6.丢包率丢包率：丢失的包与发送的全部包的比率丢包原因：（1）交换机的队列长度有限（2）包到达队列为满时将被丢弃（3）被丢弃的包（可能）需要重发7.吞吐量（通常是端到端的）吞吐量：发送者和接收者之间传输数据获得的比特率瞬时速率：在给定点测的的速率平均速率：长期传输拥有的速率瓶颈链路：制约着端-端吞吐量的那条链路8.数据发送速率越高传送的越快？9.计算机网络性能小结处理时延：存储-转发时延与发送和次数有关传播时延：与距离和介质有关丢包率：与介质和负载有关吞吐量：取决于瓶颈链路的带宽","categories":[{"name":"网络原理","slug":"网络原理","permalink":"https://tannisi.top/categories/网络原理/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://tannisi.top/tags/计算机网络/"}]},{"title":"asc18预赛通知英文原版","slug":"asc18预赛通知英文原版","date":"2018-01-19T09:03:25.000Z","updated":"2018-01-25T13:32:00.405Z","comments":true,"path":"2018/01/19/asc18预赛通知英文原版/","link":"","permalink":"https://tannisi.top/2018/01/19/asc18预赛通知英文原版/","excerpt":"asc18预赛通知英文原版","text":"asc18预赛通知英文原版","categories":[{"name":"技术比赛","slug":"技术比赛","permalink":"https://tannisi.top/categories/技术比赛/"}],"tags":[{"name":"asc18","slug":"asc18","permalink":"https://tannisi.top/tags/asc18/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-18T02:59:06.077Z","updated":"2018-01-18T02:59:06.041Z","comments":true,"path":"2018/01/18/hello-world/","link":"","permalink":"https://tannisi.top/2018/01/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"asc18预赛通知汉译版含附件","slug":"asc18预赛通知汉译版含附件","date":"2018-01-17T08:10:32.000Z","updated":"2018-01-25T13:31:46.533Z","comments":true,"path":"2018/01/17/asc18预赛通知汉译版含附件/","link":"","permalink":"https://tannisi.top/2018/01/17/asc18预赛通知汉译版含附件/","excerpt":"ASC学生超算竞赛（2018）预赛通知亲爱的参赛团队： 非常感谢你参加ASC18大学生超算竞赛，这篇文档将会提供此次比赛初赛的详细信息。1.关于这个初赛 在初赛中，每个注册队伍被要求去提交一系列文档包括一份提案，优化的源代码文件和输出文件（在附件A中有详细要求）。该提案需要用英语去写，并由ASC评估委员会审查。","text":"ASC学生超算竞赛（2018）预赛通知亲爱的参赛团队： 非常感谢你参加ASC18大学生超算竞赛，这篇文档将会提供此次比赛初赛的详细信息。1.关于这个初赛 在初赛中，每个注册队伍被要求去提交一系列文档包括一份提案，优化的源代码文件和输出文件（在附件A中有详细要求）。该提案需要用英语去写，并由ASC评估委员会审查。 2.提交指南 所有的参赛团队应当在2018年3月13日的上午八点（世界标准时间8:00）之前提交到info@asc-events.org。你的提交确认将会通过邮件发送给你。提交的内容应当包含下列项目:a) 提案文件（可以是.doc或PDF格式），用学校或学院的名字（英文中的college其实应当是大学、独立学院）和联系人的名字（例如:AAAUniversity_BBB.doc）。b）附加文档应当被压缩成一个文件（例如：AAAUniversity_BBB.zip,其他类型的压缩格式也是可以的。）除了要求的RELION文件（具体的细节要求见附件A）。压缩文件应该至少包括（具体的细节要求见附件A）: （1）HPL的输出文件 （2）HPCG的输出文件 （3）搜索查询所需的答案预测文件3.有关比赛的任何进一步查询，请通过以下电子邮件与ASC委员会联系：a）技术支持：techSupport@asc-events.orgb) 比赛组织：info@asc-events.orgc) 新闻和媒体：media@asc-events.org 我们在ASC18比赛中祝您好运！ ASC18委员会 01-16-2018 附件A：提案要求一、简要介绍大学或者学院的超级计算机活动（5分）1.超级计算机相关的硬件和软件平台2.超级计算机相关的课程、培训和兴趣小组3.超级计算机相关的研究和应用4.对超级计算机研究的关键成果（两项以上）进行详细说明，附上证明材料（公开文件、颁发证书等）。 二、团队介绍（5分）1.简述你的团队的组建过程。2.简述每个团队成员（包括团队的几组照片）。3.你的团队的口号 三、技术提案要求（90分）1.你的HPC系统的设计（15分）a)在3000瓦功率预算内，你的系统应该达到最佳的计算性能。b）制定你的系统的软件和硬件配置和互联。描述功耗，评估性能，并分析你提出的架构的优缺点。c）你的系统应当基于浪潮NF5280M5服务器。浪潮将向进入决赛的队伍提供下表中列出的组件（可能会更改配置）。其他组件（服务器本身除外）均可接受，但应该自行准备。例如，你可以更改建议配置中NF5280M5服务器和加速器的数量，硬盘和内存的类型以及以太网的类型。 项目 名称 配置 服务器 浪潮NF5280M5 CPU： 英特尔至强金牌6132*2 , 2.6GHZ ， 14 core 内存： 16G*12 ， DDR4 ， 2666Mhz 硬盘： 1T STAT * 1 功耗估算： 6132 TDP 140W （CPU）， memory 7.5W ，硬盘 10W HCA卡 FDR Infiniband Mellanox ConnectX-3 适配卡，单端口QSFP，FDR IB (主机通道适配卡) 功耗估算： 9W (INfiniband 直译为无限带宽技术） 交换机 千兆以太网交换机 10/100/1000Mb/s， 24 端口以太网交换机 功耗估算: 30W FDR-IB交换机 SwitchX FDR InfiniBand交换机，36个QSFP 端口 功耗估算： 130W 电缆 千兆CAT6电缆 CAT6铜缆 ， 蓝色 ， 3m Infiniband电缆 Infiniband FDR 光钎电缆，QSFP端口，配合Infiniband交换机使用 2.HPL 和 HPCG（15分） 建议书（提案）应当包括软件环境（操作系统，编译器，数学库，MPI软件，软件版本等）的描述，测试方法，性能优化方法，性能评估，问题和解决方案分析等。推荐HPL算法和源代码分析。 HPL软件可以被下载在：http://www.netlib.org/benchmark/hpl/. HPCG软件可以被下载在：https://github.com/hpcg-benchmark/hpcg 建议在X86的CPU或GPU平台上成功验证和优化HPL和HPCG。但是，鼓励那些无法访问平台并且不得不使用自己的硬件平台的团队提交自己的问题和结果。 3.RELION测试 a）应用背景 自成立以来，结构生物学在生物学研究中发挥着重要的作用。结构生物学试图通过解决高分辨率的生物大分子结构来解释生物过程。通常情况下，有三种方法来确定生物大分子的三维结构，包括X射线晶体学，低温电子显微镜（cryo-EM），核磁共振（NMR）。近年来，随着技术的不断创新，特别是直接电子探测相机的发展以及复杂的图像处理算法的发展，冷冻电镜已成为近原子分辨率研究生物大分子三维结构最重要的工具。该技术也被称为冷冻电镜单粒子分析（SPA），从冷冻电镜的小分子溶液开始，需要收集成千上万的高质量冷冻电镜显微照片校正（运动和畸变校正，剂量加权）和评估，对比度 传递函数（CTF）估计，粒子选择和排序，二维和三维分类，定向精化和重建以及后处理（地图锐化）。由于有限的照射剂量会产生一个非常嘈杂的生物大分子图像，嵌入到冰核中，因此需要数以万计的粒子图像来提高信噪比（SNR）。图像处理的基本原理和原理已经被充分描述 在参考中【1】。 目前最流行的用于处理冷冻电磁场数据的开源软件是RELION，它利用最大似然法和贝叶斯统计来克服低信噪比引起的每个粒子定向确定的模糊性。RELION的数学原理和算法 在参考文献[2]和[3]中进行了充分的描述。RELION的最新版本是稳定的，其源代码在参考文献[4]中可用。关于RELION的安装和使用的更多信息可以从参考文献[5]中找到。 在这里，我们提供了在细胞中储存铁的人类载脂蛋白铁蛋白复合物的cryo-EM SPA数据集。 从原始的原始显微照片中挑出原始颗粒，并堆积成不同的MRC文件（* .mrcs）。每个颗粒的成像条件和估计的CTF参数已经列在STAR文件（particle.star）中。初始低分辨率 （run_ct24_class001.mrc）。这个挑战是尝试使用RELION 2.1进行图像分析，包括2D（步骤1），3D分类（步骤2）和最终的3D重建（步骤3） ）。详细信息请参阅补充说明。参考：【1】.orlova,E.V. &amp; Saibil,H.R. structural analysis of macromolecular by electron microscopy. Chem Rev 111,7710-7748,doi:10.1021/cr100353t(2011). （奥尔洛娃，E.V。 ＆Saibil，H.R。 电子显微镜对大分子的结构分析。 Chem Rev 111,7710-7748，doi：10.1021 / cr100353t（2011）。）【2】. Scheres(2012) J.Mol.Biol.(PMID:22100448)【3】. Scheres(2012) J.Struct.Biol.(PMID:23000701)【4】. Relion source code:https://github.com/3dem/relion/releases (version 2.1 Stable)【5】. Relion wiki:http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Main_Pageb)测试命令介绍 在这个挑战中，鼓励所有参与者完成计算，获得正确的答案（原文是right rights），并尽力减少计算的需求，包括时间和资源。建议文档应包括软件环境的描述（操作系统，编译器，数学库 MPI软件和RELION版本等），测试方法，性能优化方法，性能评估，问题和解决方案分析等。对RELION算法和源代码的深入分析受到了极大的鼓励。下面列出了这个挑战的具体任务和要求。 1.编译并安装RELION，按照步骤1到步骤3的指令针对给定的数据运行程序。请提交最后一次迭代生成的文件，每个步骤的屏幕输出和每个步骤的命令行，这些文件应该压缩成 tar.gz文件（请参见下表）。要注意的是，在第3步的最后一个迭代中生成的文件不会与“ite”标记一起出现。 压缩文件的名称 内容 步骤1 Step1.Class2D.tar.gz _it025_classes.mrcs _it025_data.star _it025_model.star _it025_optimiser.star _it025_samling.star Command line file(*.sh) Screen output(*.log) 步骤2 Step2.Class3D.tar.gz _it040_class001_angdist.bild _it040_class001.mrc _it040_class002_angdist.bild _it040_class002.mrc _it040_class003_angdist.bild _it040_class003.mrc _it040_class004_angdist.bild _it040_class004.mrc _it040_data.star _it040_model.star _it040_optimiser.star _it040_sampling.star Command line file(*.sh) Screen output(*.log) 步骤3 Step3.Refine3D.tar.gz _model.star _sampling.star _data.star _class001_angdist.bild _class001.mrc Command line file(*.sh) Screen output(*.log) 要求的RELION文件应上传到百度SkyDrive或微软OneDrive，并将下载链接与上传文件的MD5代码复制到您的建议中（如果需要，请提供密码）。2.提交一个描述和总结，用什么样的计算资源（配置和架构）来完成计算，每个步骤需要多长时间（鼓励提交一个日志文件）。你也可以描述你 编译软件包，以及是否对代码进行一些修改，如何做的以及为什么。3.描述您认为（或已经执行）的策略，可以用来减少这种计算挑战的计算需求。4.请注意，每个带有其值的参数对于确保结果的一致性都是必需的。但关于应用程序性能的参数，您可以根据您的平台查看它们，但我们没有在此说明中展示它们。Step 1.运行原始粒子图像的2D分类，命令可以如下所示。输出应该像下面这样（通过反向排序的类分布显示）Step 2.运行初始参考模型的原始粒子图像的3D分类。命令如下所示。输出应该像下面这样（通过反向排序的类分布显示）Step 3.从初始参考模型开始运行3D重构和细化。命令如下所示。输出是人类apo-铁蛋白（.mrc文件）的最终重构3D结构，分辨率为〜3.3埃，可以通过使用UCSF Chimera (https://www.cgl.ucsf.edu/chimera/) 阈值为0.03（见下图）。RELION工作负载可从以下网站下载：Microsoft OneDrive:https://1drv.ms/f/s!AkxzxKN8axg2xCptYHmT1QMN_iQ-orBaidu SkyDrive:https://pan.baidu.com/s/1nwpZFHv Password: vsyh(两个网站上的数据是相同的，你可以选择任何一个网站下载) 4.搜索查询的答案预测（30分）任务 建立一个具有阅读理解能力（RC）或对现实世界数据的开放式问题回答（QA）的智能代理（我认为是助理）是人工智能的一个主要目标。这样的助理可以为消费者带来巨大的价值，因为他们可以为个人助理提供支持，如Cortana，Siri，Alexa或Google Assistant，这些都是近期深度语音识别技术发展的助力。随着这些类型的助理逐渐普及，消费者发现通过语音辅助来快速获得答案，而不是通过搜索引擎结果页面和网页浏览器，可以更方便地提出问题。具有RC和QA能力的智能代理也可以 具有令人难以置信的商业价值，通过动力的机器人自动化客户服务代理通过消息或聊天界面发现的业务。MSMARCO是一个大型的真实世界的阅读理解数据集，针对上述任务。数据集中的问题是通过Bing或Cortana发出的真实匿名查询，文档是相关的网页，可能会或可能不足以回答问题。对于数据集中的每一个问题，我们都要求众包工作者回答它，如果可能的话，还要标记相关的段落，为答案提供支持信息。如果他们不能回答，我们就认为这个问题是无法回答的，我们也包括MSMARCO中的样本。（不清楚这是什么意思！） 答案强烈建议采用完整的句子形式，因此工作人员可以自己写一个长篇文章.MSMARCO包括10万个问题，100万个段落，以及超过20万个文档的链接。任务需要用户找到最好的算法，可以找到所有候选人（段落）的最佳答案（段落），或者自己写出最佳答案（段落）。 数据集 格式数据库使用JSON格式化，每个例子有五个字段： 字段 定义 查询 问题查询来自Bing搜索引擎的真实用户 段落 从公共Web文档中提取的前10个关联段落来回答 文档链接 为查询排名的顶级文档的URL。这些文档是上下文段落的来源 答案 答案合成来自查询的人工判断，自动提取段落及其相应的公共Web文档 分割 QA分类标签。 例如，南美洲最高的山属于实体部分，因为答案是一个实体（阿空加瓜） 注意：描述查询的唯一目标（例如使用“query_type”：“description”） 挑战将使用两个不同的数据集初赛和决赛。请注意，只有训练和开发集有标签。 阶段1 （初步） 训练集 https://msmarco.blob.core.windows.net/msmarco/train_v1.1.json.gz 开发集 https://msmarco.blob.core.windows.net/msmarco/dev_v1.1.json.gz 测试集 https://msmarco.blob.core.windows.net/msmarco/test_public_v1.1.json.gz 阶段2 （决赛） 训练集 将会在决赛的时候宣布 开发集 将会在决赛的时候宣布 测试集 将会在决赛的时候宣布 结果提交A：每个团队都应该提交一个名为output.json的文件，该文件包含Test.Set上每个描述查询的答案（段落）。测试结果应该使用JSON，并遵循以下格式： 翻译：{“询问”：“化石燃料有什么好处”，“查询_ID”：0，“查询类型”：“描述”，“答案”：[“使用化石燃料最大的好处是它们可以储存简单，方便运输。因此大量的煤炭储备从煤矿被运送到远离煤矿的产业。”]} 字段 定义 查询 问题查询与测试集中的查询相同 查询ID 应该与Test Set中的query_id相同 查询类型 可选的 答案 应该只包含一个由您的算法输出的最佳答案 B：对于初始阶段和最终阶段，每个团队还应该提交一个包含CNTK代码和模型的文件夹，以便重现测试结果。 文件夹的结构应该像这样: 注意： 1.每个团队只提交一个测试文件（output.json）和相应的源代码和模型。 2.委员会可以运行提交的CNTK代码，以确保提交的测试结果的合法性和有效性。 3.委员会将忽略任何不遵守规则的提交。请在提交前用评分脚本检查结果文件。 指标：任务使用ROUGE-L作为排名模型质量的度量，并使用下面的代码来评分和输出ROUGE-L得分。 根据研究论文(http://www.aclweb.org/anthology/W/W04/W04-1013.pdf) ,ROUGE-L是基于最长公共子序列(LCS)的统计量.ROUGE-L首先找出最长的共同点 在长度为m的候选通道（X）与长度为n的参考通道（Y）之间的子序列（LCS）。 注意当两条通道相同（X = Y）时，ROUGE-L为1，当LCS（X，Y）= 0时，ROUGE-L为零。 代码评分和输出指标https://msmarco.blob.core.windows.net/msmarco/ms_marco_eval.tar.gz 训练框架 您必须使用CNTK框架(https://github.com/Microsoft/CNTK) 作为解决方案的深度学习部分。使用或依赖于任何其他深度学习框架将会放弃您的提交。 要安装CNTK，请按照(https://docs.microsoft.com/en-us/cognitive-toolkit/setup-windows-python) 中的说明进行操作。您可以简单地用“pip install ‘与之匹配的CNTK python滚轮 你的相应steup。（我认为这里的意思应该是用pip来自动安装合适的版本）。 CNTK 文件：https://cntk.ai/pythondocs/ 掌握基本的笔记教程，推进深入的学习任务：https://github.com/Microsoft/CNTK/tree/master/Tutorials 相关的文本处理教程： 1.语言理解的简单例子：https://github.com/Microsoft/CNTK/blob/master/Tutorials/CNTK_202_Language_Understanding.ipynb 2.序列将一个句子从一种语言转换为另一种语言的例子：https://github.com/Microsoft/CNTK/blob/master/Tutorials/CNTK_204_Sequence_To_Sequence.ipynb 3.用LSTM进行深层结构语义建模：https://github.com/Microsoft/CNTK/blob/master/Tutorials/CNTK_303_Deep_Structured_Semantic_Modeling_with_LSTM_Networks.ipynb 基线代码这里是MS宏数据集的CNTK基线训练代码：https://github.com/Microsoft/CNTK/tree/nikosk/bidaf/Examples/Text/BidirectionalAttentionFlow/msmarco 上面的训练代码是用Python编写的，它包含转换器脚本，它将MSMARCO数据库转换为可由CNTK阅读器使用的CTF CNTK格式（您可以编写自己的Python代码来读取数据并将其提供给教练，但速度会更慢 ），以及端到端的培训脚本。 硬件要求 强烈建议在GPU平台上运行训练代码。 有任何相关的问题，请联系techsupport@asc-events.org 更新于2018年 01月 20日 星期六 19:24:04 CST","categories":[{"name":"技术比赛","slug":"技术比赛","permalink":"https://tannisi.top/categories/技术比赛/"}],"tags":[{"name":"asc18","slug":"asc18","permalink":"https://tannisi.top/tags/asc18/"}]},{"title":"操作系统结构简述","slug":"操作系统结构简述","date":"2018-01-14T10:56:04.000Z","updated":"2018-01-25T13:23:12.625Z","comments":true,"path":"2018/01/14/操作系统结构简述/","link":"","permalink":"https://tannisi.top/2018/01/14/操作系统结构简述/","excerpt":"1.单体操作系统 在大多数常见的组织中，整个操作系统在内核态以单一程序的方式运行。整个操作系统一过程集合的方式编写，链接成一个大型可执行二进制程序。 使用这种技术，系统中每个过程可以自由调用其他过程，只要后者提供了前者所需要的一些有用的计算工作。调用任何一个你所需要的过程，或许会非常高效，但上千个可以不受限制地彼此调用的过程常常会导致系统笨拙且难于理解。并且任何一个系统的崩溃都会连累整个系统。","text":"1.单体操作系统 在大多数常见的组织中，整个操作系统在内核态以单一程序的方式运行。整个操作系统一过程集合的方式编写，链接成一个大型可执行二进制程序。 使用这种技术，系统中每个过程可以自由调用其他过程，只要后者提供了前者所需要的一些有用的计算工作。调用任何一个你所需要的过程，或许会非常高效，但上千个可以不受限制地彼此调用的过程常常会导致系统笨拙且难于理解。并且任何一个系统的崩溃都会连累整个系统。 （这里我认为是由于各个过程以集合的方式组织在一起的结构所导致的即集合的性质，不知理解的是否正确！） 在使用这种处理方式构造实际的目标程序时，首先编译所有单个的过程（或者编译包含过程的文件），然后通过系统链接接程序将它们链接成单一的目标文件。 可是即使在单体结构中，也有一些结构存在。可以将参数设置在良好定义的位置（如栈），通过这种方式，向操作系统请求所能提供的服务（系统调用），然后执行一个陷阱指令（将机器从用户态切换到内核态所进行的指令，陷阱指内陷到操作系统内核中）。 对于这类操作系统的基本结构，有着如下结构上的建议： 1.需要一个主程序用来处理服务过程请求。 2.需要一套服务过程，用来执行系统调用。 3.需要一套实用过程，用来辅助服务过程。（如用户程序取数据等） 除了在系统初启时所装载的核心操作系统，许多操作系统支持可装载的扩展，例如：I/O设备驱动和文件系统。在UNIX中他们被叫做共享库（shared library），在Windows中则被称作动态链接库（DLL），他们的扩展类型为.dll，在C:\\Windows\\system32目录下存在1000多个DLL文件。 2.层次式系统 它的上层软件都是在在下一层软件的基础之上构建的。THE系统（1968）是按此模型构造的第一个操作系统。他是一个简单的批处理操作系统。该系统共分为六层，如下图所示: 层号 功能 5 操作员 4 用户程序 3 输入/输出管理 2 操作员——进程通信 1 存储器和磁鼓管理 0 处理器分配和多道程序设计 THE操作系统的结构第0层：处理器分配在第0层中进行，当中断发生或定时器到期时，由该层进行进程切换。在第0层之上，系统由一些连续的进程所组成，编写这些进程时不再考虑在单处理器上多进程进行的细节。也就是说，在第0层中提供了基本的CPU多道程序设计功能。第1层：内存管理在第1层中进行，它分配进程的主存空间，当内存用完时，则在一个512k字的磁鼓上保留进程的一部分（页面）（我认为这种方法跟交换空间（swap）是差不多的）。在第一层上，进程不用考虑它是在磁鼓上还是在内存中运行。第一层的软件保证一旦需要访问某一页面，该页面必定已在内存中，并在页面不再需要时将其移出。第2层：处理进程与操作员控制台（即用户）之间的通信。在这层的上部，可以认为每个进程都有自己的操作员控制台第3层：管理I/O设备和相关的信息流缓冲区。在第三层上每个进程都与有良好特性的抽象I/O设备打交道，而不必考虑外部设备的物理细节。第4层：用户程序层。用户程序不需要考虑进程、内存、控制台或I/O设备管理等细节。第5层：系统操作员进程。 下面介绍一下MULTICS系统 在MULTICS系统中采用了更进一步的通用层次化概念。MULTICS由许多的通信换构造而成，而不是采用层次化构造，内环比外环有更高的级别（他们实际上是一样的）。当外环的过程欲调用内环的过程时，他必须执行一条等价于系统调用的TRAP指令。在执行该TRAP指令之前，要进行严格的参数合法性检查。在MULTICS中，尽管整个操作系统是各个用户进程的地址空间的一部分，但是应尽仍能对单个过程（实际上是内存中的一个段）的读、写和执行进行保护。比较THE系统和MULTICS系统的不同：THE分层方案只是为设计提供了一些方便，因为该系统的各个部分最终仍然被链接成了完整的单个目标程序。（这里我认为它跟上面的单体系统有些相似）MULTICS系统的环形机制在运行中是实际存在的，而且是由硬件实现的。环形机制的一个优点是很容易扩展，可用以构造用户子系统。举例说明：在一个MULTICS系统中，教授可以写一个程序检查学生编写的程序并给他们打分，在第n个环中运行教授的程序，而在第n+1个环中运行学生的程序，这样学生就无法篡改教授所给出的成绩了。（我认为这主要是靠系统在执行TRAP指令前，要进行严格的参数合法性检查这一行为所实现的。） 3.微内核 在分层设计中，设计者要确定在哪里划分内核-用户的边界。传统上，所有的层都在内核中，但是尽可能减少内核态中功能的做法更好，因为内核中的错误会快速的拖累系统。相反，可把用户进程设置为具有较小的权限，这样某个错误的后果就不会是致命的。（代码错误的密度䚧模块大小、模块寿命等，不过对一个实际的工业系统而言，每千行代码中会有2~10个错误，这意味着在有500万行代码的单体操作系统中，大约有10000~50000个内核错误，但并不是所有的错误都是致命的。） 在微内核设计背后的思想是，为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态，其余的模块由于功能相对弱些，则作为普通用户进程运行。特别地，由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个操作系统死机。 但是在单体操作系统中，由于所有的设备驱动都在内核中，一个有故障的音频驱动很容易引起对无效地址的引用，从而造成系统停机。 除了比较著名的基于Mach微内核OS X外，通常的桌面操作系统并不使用微内核。但是微内核在工业中却特别流行，因为微内核具有高度的可靠性。 这里对MINIX3做一简单的介绍，该操作系统把模块化的思想推到了极致，它将大部分操作系统分解成许多独立的用户态进程，其最受POSIX标准。MINIX3微内核只有12000行代码和1400行用于非常低层次功能的汇编代码，诸如捕获中断、进程切换等，C代码管理和调度进程、处理进程间通信（在进程间传送消息）、提供大约40个内核调用，他们似的操作系统的其余部分可以完成其工作。这些调用完成诸如连接中断句柄、在地址空间中移动数据以及为新创建的进程安装新的内存映像等功能。MINIX的进程结构如下图所示：其中内核调用句柄用Sys标记，始终设备驱动也在内核中，因为这个驱动与调度器交互密切。所有的其他设备驱动都作为单独的用户进程运行。在内核的外部，系统的构造有三层进程，他们都在用户态运行。（1）最底层中包含设备驱动器。由于他们在用户态运行，所以不能物理的访问I/O端口空间，也不能直接的发出I/O命令。相反，为了能够对I/O设备编程，驱动器建了一个结构，指明哪个参数值写到哪个I/O端口，并生成一个内核调用，并通知内核完成写操作。（2）在驱动器上面是另一用户层，包含有服务器，它们完成操作系统的多数工作。由一个或多个文件服务器管理着文件系统，进程管理器创建、销毁和管理进程等。通过给服务器发送短消息请求POSIX系统调用的方式，用户程序获得操作系统的服务。（3）有一个有趣的服务器，称为“再生服务器”，其任务是检查其他服务器和驱动器的功能是否正确。一旦检查出了错误，它自动取代之，无需用户的干预。这种方式使得系统具有自我修复的能力，并且获得了较高的可靠性。（4）系统对每个进程的权限有着许多的限制。所有这些权限是让每个驱动和服务器只拥有完成其工作所需要的权限，这样就极大地限制了故障部件可能造成的危害。（5）一个于小内核相关联的思想是内核中的“机制与策略分离的原则”。为了说明这一点，我们考虑进程调度。一个比较简单的调度算法是：对每个进程赋予一个优先级，并让内核执行具有最高优先级的内容。这里，机制（在内核中）就是寻找最高优先级的进程并运行之。而策略（赋予进程优先级）可以有用户态中的进程完成。在这种方式中，机制和策略是分离的，从而使系统内核变得更小。 4. 客户端-服务器模式 一个微内核思想的略微变体是将进程划分为两类：服务器（每个服务器提供某种服务），客户端（使用这些服务）。这种模式就是客户端——服务器模式。通常在系统最底层的是微内核，但并不是必须这样。这个模式的本质是存在客户端进程和服务器进程。 一般来说服务器客户端之间的通信是“消息传递”。为了获得一个服务，客户端进程构造一段消息，说明所需要的服务，并将其发给合适的服务器。该服务器完成工作，发送回应。 这种思想的一个显然的普遍方式是，客户端和服务器运行在不同的计算机上，它们通过局域网或广域网连接，其结构如下图所示：由于客户端通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地计算机上处理，还是通过网络被送到远程计算机上处理。对于客户端而言，这两种情形都是一样的：都是发送请求并得到回应。所以服务器客户端模式是一种可以应用在单机或网络机器上的抽象。（许多web就是以这个方式运行的） 5.虚拟机1.VM/370 这个系统最初被命名为CP/CMS，后来改名为VM/370.他是源于如下机敏的观察，即分时系统应该提供这些功能：（1）多道程序（2）一个比裸机更方便，有扩展界面的计算机。而VM/370存在的目的是将两者彻底地隔离开来。 这个系统的核心称为“虚拟机监控程序”，他在逻辑上运行并具备了多道程序功能。该系统向上层提供了若干台虚拟机。这些虚拟机并不那种具有文件等优良特征的扩展计算机。他们仅仅是裸机硬件的精确复制品。这个复制品包括了内核态/用户态、I/O功能、中断及其它真实硬件所应该具有的全部内容。 在早期的VM/370系统上，有一些系统运行OS/360或者其他大型批处理或事务处理操作系统，而另一些虚拟机运行单用户、交互式系统供分时用户使用，这个系统称为“会话监控系统（CMS）”，后者在程序员之间非常流行。 当一个CMS程序执行系统调用时，该调用被陷入到其虚拟机上的操作系统上，而不是VM370上，似乎它运行在实际的机器上，而不是在虚拟机上。CMS然后发出普通的硬件I/O指令读出虚拟磁盘或其他需要执行的调用。这些I/O指令由VM/370陷入，然后作为对实际硬件模拟的一部分，VM/370完成指令。通过对多道程序功能和提供扩展机器二者的完全分离，每个部分变得非常简单、非常灵活且容易维护。 虚拟机的现代化身z/VM通常用于运行多个完整的操作系统，而不是简化成如CMS一样的单用户操作系统。 2.虚拟机的再次发现 首先看需求，传统上，许多公司在不同的计算机上，有时还在不同的操作系统上，运行其邮件服务器、web服务器、FTP服务器以及其他服务器。他们看到可以在同一台机器上实现虚拟化来运行所有的服务器，而不会由于一个服务器崩溃而影响其他系统。虚拟化在web托管世界也很流行。没有虚拟化，Web托管客户端只能共享托管以及独占托管。 虚拟化的另一个用途是，为希望同时运行两个或多个操作系统的最终用户服务，某个偏好的应用程序可运行在一个操作系统上，而其他的应用程序可运行在另一个操作系统上。如下图所示：在这里术语“虚拟机监控程序”已经被重新命名为第一类虚拟机管理程序，在虚拟机的实现上存在问题，为了在一台计算机上运行虚拟机软件，其CPU必须被虚拟化，简言之，存在一个问题，当运行虚拟机（在用户态）的操作系统执行某个特权指令时，比如修改PSW或进行I/O操作，硬件实际上陷入到了虚拟机中，这样有关指令就可以在软件中模拟。在某些CPU上（特别是Pentium和它的后继者及其克隆版中）试图在用户态执行特权指令是，会被忽略掉。这种特性使得在这类硬件中无法实现虚拟机，这也解释了PC界对虚拟机不感兴趣的原因。 一些早期研究项目通过即时翻译大块代码、将其存储到内部高速缓存并在其再次执行时复用的方式提高了Bochs等翻译器的性能，也推动了模拟器的出现，如上图b）所示，该技术被称为“二进制翻译”。改善性能的下一步在于添加分担重担的内核模块，如上图c）所示，事实上，现在所有商用可用的虚拟机管理程序都是用这种混合策略，如VWware工作站。他们被称为第二类虚拟机管理程序. 实际上，第一类虚拟机和第二类虚拟机管理程序的真正区别在于，后者利用宿主操作系统并通过其文件系统创建进程、存储文件等。第一类虚拟机管理程序没有底层支持，所以必须自行实现所有功能。 当第二类虚拟机管理程序启动时，它从CD-ROM安装盘中读入供选择的客户操作系统，并安装在一个虚拟盘上该盘实际上是宿主操作系统的文件系统上的一个大文件。由于没有可以存储文件的操作系统，因此第一类虚拟机管理程序不能采用这种方式。 处理控制指令的一种不同的方式是，修改操作系统，然后删掉他们。这种方式是半虚拟化。 3.Java虚拟机 另一个使用虚拟机的领域，是为了运行Java程序(例如Android就是在Linux内核上使用Java解释器来运行Java程序)，但方式有些不同，在Sun公司发明Java程序设计语言时，也发明了称为JVM的虚拟机（一种体系结构）。Java编译器为JVM生成代码，这些代码以后可以由一个软件JVM解释器执行。这种处理方式的优点在于，JVM代码可以通过Internet传送到任何有JVM解释器的计算机上，并在该机器上执行。使用JVM的另一种优点是，如果解释器正确的完成并不意味着就结束了还要对输入的JVM进行安全性检查，然后在一种保护环境下执行，这样，这些数据就不能偷窃数据或进行其他任何有害的操作。 6.外核 与虚拟机克隆真是极其不同，另一种策略是对机器进行分区。在底层中，一种称为“外核”的程序在内核态中运行。它的任务是为虚拟机分配资源，并检查用这些资源的企图，已确保没有机器会使用他人的资源。每个用户层的虚拟机都可以运行自己的操作系统，但限制只能使用已经申请并获得分配的哪部分资源。 外核机制的优点是（1）减少了映像层，不需要重映像磁盘地址的处理了（2）将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且负载并不重，这是因为外核所做的只是保持多个虚拟机彼此不发生冲突。","categories":[{"name":"现代操作系统学习","slug":"现代操作系统学习","permalink":"https://tannisi.top/categories/现代操作系统学习/"}],"tags":[{"name":"操作系统结构","slug":"操作系统结构","permalink":"https://tannisi.top/tags/操作系统结构/"}]},{"title":"利用hexo+github建立个人技术博客","slug":"利用hexo-github建立个人技术博客","date":"2018-01-12T13:31:15.000Z","updated":"2018-01-18T02:46:12.773Z","comments":true,"path":"2018/01/12/利用hexo-github建立个人技术博客/","link":"","permalink":"https://tannisi.top/2018/01/12/利用hexo-github建立个人技术博客/","excerpt":"","text":"1.创建github账号","categories":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://tannisi.top/categories/搭建blog/"}],"tags":[{"name":"hexo+github","slug":"hexo-github","permalink":"https://tannisi.top/tags/hexo-github/"}]},{"title":"github+hexo搭建个人技术博客遇到的问题以及解决方案","slug":"github-hexo搭建个人技术博客遇到的问题以及解决方案","date":"2018-01-12T07:24:54.000Z","updated":"2018-01-25T08:24:18.938Z","comments":true,"path":"2018/01/12/github-hexo搭建个人技术博客遇到的问题以及解决方案/","link":"","permalink":"https://tannisi.top/2018/01/12/github-hexo搭建个人技术博客遇到的问题以及解决方案/","excerpt":"hexo删除博客中已有的文章 删除仓库里面 source/_posts/我的文章.md 执行下列命令更新博客： hexo clean #清除缓存 hexo g == hexo generate#生成（hexo s == hexo server#启动服务预览，其实不用执行这一步，这一步只是用来看修改后的后果，作用类似于打印预览） hexo d == hexo deploy#部署","text":"hexo删除博客中已有的文章 删除仓库里面 source/_posts/我的文章.md 执行下列命令更新博客： hexo clean #清除缓存 hexo g == hexo generate#生成（hexo s == hexo server#启动服务预览，其实不用执行这一步，这一步只是用来看修改后的后果，作用类似于打印预览） hexo d == hexo deploy#部署 关于hexo主题的更改 我们可以去hexo的themes中去找,网址:https://hexo.io/themes/ 从中选一个主题，单击主题的名字 如:next 进入到它在github上的资源，阅读README.md，安装即可。 怎么在Markdown文档中加入下划线或中划线在Markdown中，中划线很简单语法：效果：关于下划线，html和行内CSS就可以解决：（1）方案一：利用u标签快速添加下划线，但是它有两个缺点：1.HTML5规范建议开发者尽量使用其他元素替代u元素。2.u标签的下划线自定义程度低，只有黑色一种颜色（可能是我不知道怎么做吧！）（2）方案二：使用html的span标签、设置行内CSS的border-bottom属性来添加下划线。这种方式自定义程度最高。语法：效果：所添加的需要添加下划线的行内文字","categories":[{"name":"搭建blog","slug":"搭建blog","permalink":"https://tannisi.top/categories/搭建blog/"}],"tags":[{"name":"问题解决方案","slug":"问题解决方案","permalink":"https://tannisi.top/tags/问题解决方案/"}]}]}