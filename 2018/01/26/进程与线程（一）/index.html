<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=https://tannisi.top/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=https://tannisi.top">
<meta name="author" content="tannisi">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/SimpleStyle.min.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>进程与线程（一） - 坦尼斯</title>

<meta name="keywords" content="">

<meta name="description " content="linux/unix study">
</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="说">说</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">说IT</h1>
        <h3 class="cover-siteTitle">做产品，写代码</h3>
        <p class="cover-siteDesc">一个关注技术与人文的IT博客</p>
        <div class="cover-sns">
            
            <div class="btn btn-telegram">
                <a href="http://t.me/kunyintang" target="_blank" title="telegram" ref="friend">
                    <i class="fa fa-telegram"></i>
                </a>
            </div>
            
            <div class="btn btn-instagram">
                <a href="https://www.instagram.com/mtangsir/" target="_blank" title="instagram" ref="friend">
                    <i class="fa fa-instagram"></i>
                </a>
            </div>
            
            <div class="btn btn-twitter">
                <a href="https://twitter.com/tangkunyin" target="_blank" title="twitter" ref="friend">
                    <i class="fa fa-twitter"></i>
                </a>
            </div>
            
            <div class="btn btn-github">
                <a href="https://github.com/tangkunyin" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>
        
            
                <li class="">
                    <a href="/categories/big-front-end" data-name="前端">前端</a>
                </li>
            
                <li class="">
                    <a href="/categories/server-side" data-name="后台">后台</a>
                </li>
            
                <li class="">
                    <a href="/categories/design" data-name="设计">设计</a>
                </li>
            
                <li class="">
                    <a href="/categories/resource" data-name="资源">资源</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="请输入关键字" />
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="" target="_blank">
                    <img width="48" src="" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="" target="_blank"></a>
                    <span title="最后编辑于2018-01-26">2018-01-26</span>
                </p>
                <p></p>
            </div>
            <h2 class="post-title">进程与线程（一）</h2>
            <div class="post-meta">
                本文总共5734个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <p>   操作系统中最核心的概念是<span style="border-bottom:2px dashed red;">进程</span>：这是对正在运行程序的一个抽象。操作系统的其他所有内容都是围绕着进程的概念展开的。<br>   即使可以使用的CPU只有一个，但他们也具有支持（伪）并发操作的能力，它们将一个单独的CPU变换成多个虚拟的CPU。可以说：<span style="border-bottom:2px dashed red;">没有进程的抽象，现代计算将不复存在。</span><br><a id="more"></a></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>   在任何多道程序设计系统中，CPU由一个进程快速切换至另一个进程，使每个进程各运行几十或几百毫秒。严格地说，在某一个瞬间，CPU只能运行一个进程。但在一秒钟内，它可能运行多个进程，这样就产生并行的错觉。有时人们所说的伪并行就是指这种情形，以此来区分多处理器系统（该系统有两个或多个CPU共享一个物理内存）的真正硬件并行。</p>
<h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>   在进程模型中，所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称“进程”。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。从概念上说，每个进程有它自己的虚拟CPU。当然实际上真正的CPU在各个进程之间来回切换。这种快速切换，被称为<span style="border-bottom:2px dashed red;">多道程序设计</span>。<br>   在下图（a）中可以看到，在一台多道程序计算机的内存中有四道程序。在下图（b）中，这4道程序被抽象为4个各自拥有自己控制流程（即每个程序自己的逻辑程序计数器）的进程，并且每个程序都独立地运行。当然实际上只有一个物理程序计数器，所以在每个程序运行时，它的逻辑程序计数器被装入实际的程序计数器中。当该程序执行结束（或暂停执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。在下图c中可以看到，在观察足够长的一顿时间后，所有的程序都运行了，但在任何一个给定的瞬间仅有一个进程真正在运行。<br><img src="/2018/01/26/进程与线程（一）/1.jpg" alt="(a)含有4道程序的多道程序(b)4个独立的顺序进程模型(c)在任意时刻仅有一个程序是活跃的"><br>   由于CPU在各进程之间来回快速切换，所以每个进程执行器运算的速度是不确定的。而且当同一进程再次运行时，其运算速度通常不可再现。所以在对进程编程时决不能对时序做任何想当然的假设。然而，通常大多数进程并不受CPU多道程序设计或其它进程相对速度的影响。<br>   <span style="border-bottom:2px dashed red;">进程和程序间的区别是非常微妙的，但非常重要。</span>用一个比喻可以很容易理解这一点：想象有一位计算机科学家在位他的女儿烘制蛋糕。他有做生日蛋糕的食谱，厨房里有所需要的原料。则做蛋糕的食谱就是程序（即用适当形式描述的算法），计算机科学家就是CPU，厨房里的原料就是输入数据。<span style="border-bottom:2px dashed red;">进程就是厨师阅读食谱、取来原料以及烘制蛋糕等一系列动作的综合。</span><br>   关键思想：<span style="border-bottom:2px dashed red;">一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</span><br>   值得注意的是,<span style="border-bottom:2px dashed red;">如果一个程序运行了两遍，则算作两个进程。</span></p>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>   在通用操作系统中，需要有某种方法在运行时按需要创建或撤销进程，现在开始考察这个问题。<br>   4种主要事件会导致进程的创建：<br>（1）系统初始化<br>（2）正在运行的程序执行了创建进程的系统调用<br>（3）用户请求创建一个新的进程<br>（4）一个批处理作业的初始化</p>
<ul>
<li>启动操作系统时，通常会创建若干个进程。其中有些是前台进程，也就是同用户（人类）交互并且替他们完成工作的那些进程。其他的是后台进程，这些进程与特定的用户没有关系，相反却具有某些专门的功能。<span style="border-bottom:2px dashed red;">停留在后台处理诸如电子邮件、web页面、新闻、打印之类的活动的进程称为守护进程。</span>在大型系统中有很多守护进程。在UNIX中，可以用ps程序列出正在运行的进程；在Windows中，可使用任务管理器。</li>
<li>一个正在运行的进程经常发出系统调用，以便创建一个或多个新进程协助其工作。在所要从事的工作可以很容易的划分出成个若干相关的但没有相互作用的进程时，创建新的进程就特别有效果。</li>
<li>在交互式系统中，键入一个命令或点击一个图标就可以启动一个程序。这两个动作中的任何一个都会创建一个新的进程，并在其中运行所选择的程序。在基于命令行的UNIX系统中运行程序X，新的进程会从该进程接管它的窗口。</li>
<li>最后一种创建进程的情形仅在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。在操作系统认为有资源可运行另一个作业时，它会创建一个新的进程，并运行其输入队列中的下一个作业。<br>从技术上看，在以上所有的情形中，新进程都是由于一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。这个进程所做的工作是，执行一个用来创建进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接地指定在该进程中运行的程序。<br><span style="border-bottom:2px dashed red;">在UNIX系统中，只有一个系统调用可以用来创建新的进程：fork。这个系统调用会创建一个与调用进程相同的副本。在调用了fork之后，这两个进程（父进程和子进程）拥有相同的内存映像、同样的环境字符串和同样的打开文件。这就是全部情形。通常子进程接着执行execve或一个类似的系统调用，已修改其内存映像并运行一个新的程序。之所以要安排两步建立进程，是为了在fork之后但在execve之前允许该子进程处理描述其文件描述符，这样就可以完成对标准输入文件、标准输出文件和标准错误文件的重定向。</span><br>在Windows中情形正好相反，一个Win32函数调用CreateProcess（该调用有10个参数）既处理进程的创建，也负责把正确的程序装入新的进程。除了CreatProcess，Win32中有大约100个其他的函数用于处理进程的管理、同步以及相关的事务。<br>在UNIX和Windows中，进程创建之后，父进程和子进程各拥有不同的地址空间。如果其中某个进程在地址空间中修改了一个字，这个修改对其他进程而言是不可见的。<span style="border-bottom:2px dashed red;">在UNIX中，子进程的初始地址空间是个父进程的一个副本，但是这里涉及两个不同的地址空间，不可写的内存区是共享的。</span>某些UNIX的实现使程序正文在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但这种情况先内存通过<span style="border-bottom:2px dashed red;">写实复制</span>共享，这意味着一旦两者之一想要修改部分内存 ，则这块内存<span style="border-bottom:2px dashed red;">首先被明确地复制，以确保修改发生在私有内存区域。再次强调，可写的内存是不可以共享的。</span>但是对于一个新创建的进程而言，确实有可能共享其创建者的其他资源，例如打开的文件等。<span style="border-bottom:2px dashed red;">在Windows中，从一开始父进程的地址空间和子进程的地址空间就不同。</span><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2>新的进程的终止，通常由下列条件引起：<br>（1）正常退出（自愿的）<br>（2）出错退出（自愿的）<br>（3）严重错误（非自愿的）<br>（4）被其他进程杀死（非自愿的）</li>
<li>多数进程是由于完成了它们的工作而终止。当编译器完成了所给定程序的编译之后，编译器执行一个系统调用，通知操作系统它的工作已经完成。在UNIX中该调用是exit，而在Windows中，相关的调用是ExitProcess。</li>
<li>第二个原因是：进程发现了严重错误。<span style="border-bottom:2px dashed red;">在给出了错误参数时，面向屏幕的交互进程通常并不退出。相反，这些程序会弹出一个对话框，并要求用户再试一次。</span></li>
<li>第三个原因：由进程引起的错误，通常是由于程序中的错误所致。例如执行了一条非法指令、引用不存在的内存、除数为0等。有些系统中（如UNIX），进程可以通知操作系统，它希望自行处理某些类型的错误，在这类错误中，进程会收到信号（被中断），而不是在这类错误出现时终止。</li>
<li>第四个原因：某个进程执行一个系统调用通知操作系统杀死某个其他的进程。在UNIX中这个系统调用是kill，在Win32中对应的函数是TerminateProcess。在这两种情形中，“杀手”都必须获得确定的授权以便进行动作。（在Linux中一般要赋予root权限，才能执行kill操作）<h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2>某些系统中，当进程创建了另一个进程后，父进程和子进程就以某种形式继续保持关联。子进程自身可以创建更多的进程，组成一个进程的层次结构。进程只有一个父进程，但是可以有零个、一个、两个或多个子进程。<br>在UNIX中，进程和它的所有子进程以及后裔共同组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被该信号杀死。<br>考虑UNIX系统在启动时如何初始化自己。<span style="border-bottom:2px dashed red;">一个称为init的特殊进程出现在启动映像中，当它开始运行时，读入一个说明终端数量的文件。接着，为每个终端创建一个新进程。这些进程等待用户登录。如果有一个用户登录成功，该登陆进程就执行一个shell准备接收命令。</span>所接收的命令会启动更多的进程，以此类推，这样整个系统中，所有的进程都属于以init为根的一棵树。<br>相反，在Windows中没有进程层次的概念，所有的进程地位都是相同的。唯一类似于进程层次的暗示是在创建进程的时候，父进程得到一个特别的令牌<span style="border-bottom:2px dashed red;">（称为句柄）</span>,该句柄可以用来控制子进程。但是，它有权把这个令牌传送给某个其他的进程，这样就不存在进程层次了。在UNIX中，进程就不能剥夺其子进程的“继承权”。<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是进程之间经常需要相互作用。一个进程的输出结果可能作为另一个进程的输入。当一个进程在逻辑上不能继续运行时，他就会被阻塞，典型的例子是它在等待可以使用的输入。还可能有这样的情况：一个概念上能够运行的进程被迫停止，因为操作系统调度另一个进程占用了CPU。这两种情况是完全不同的。在第一种情况下，进程挂起是程序固有的原因（在键入用户命令行之前，无法执行命令）。第二种情况则是由于系统技术上的原因引起的（由于没有足够的CPU，所以不能使每个进程都有一台私用的处理器）。在图1中可以看到显示进程的三种状态的状态图，这三种状态是：（1）运行态（该时刻进程实际占用CPU）（2）就绪态（可运行，但因为其它进程正在运行而暂时停止）（3）阻塞态（除非某种外部事件发生，否则进程无法运行）。<br><img src="/2018/01/26/进程与线程（一）/2.jpg" alt="图1 一个进程可处于运行态、阻塞态和就绪态，图中显示出个状态之间的转换"></li>
<li>进程的三种状态之间有四种可能的转换关系。如图1所示。在操作系统发现进程不能运行下去时，发生转换1。在某些系统中，进程可以执行一个诸如pause的系统调用来进入阻塞状态。</li>
<li>转换2和3是由进程调度程序引起的，进程调度程序是操作系统的一部分，进程甚至感觉不到调度程序的存在。系统认为一个运行进程占用处理器的时间已经过长，决定让其他进程使用CPU时间时，会发生转换2.在系统已经让所有其他进程享有了他们应当应有的公平待遇而重新轮到第一个进程再次占用CPU时间时，会发生转换3。</li>
<li>当进程等待的一个外部事件发生时（如一些输入到达），则发生转换4.如果此时没有其他进程运行，则立即触发转换3，该进程便开始运行。否则该进程将处于就绪态，等待CPU空闲并且轮到它运行。<br><span style="border-bottom:2px dashed red;">调度程序的主要工作就是决定应当运行哪个进程、何时运行及它应该运行多长时间，这是很重要的一点。</span><h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2>为了实现进程模型，<span style="border-bottom:2px dashed red;">操作系统维护着一张表格（一个结构数组），即进程表。每个进程表占用一个进程表项。（有时也称进程控制块）该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未中断过一样。</span><br>图2展示了在一个典型系统中的关键字段。<br><img src="/2018/01/26/进程与线程（一）/3.jpg" alt="图2 典型的进程表表项中的一些字段"><br>与每一I/O类关联的是一个称作中断向量的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入栈堆，计算机随机跳转到中断向量所指示的地址。这些是硬件完成的所有操作，然后软件，特别是终端服务例程就接管一切剩余的工作。<br>所有的中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。随后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作，无法用C语言这一类高级语言来描述，所以这些操作通常通过一个短小的汇编语言里程来完成，通常该例程可以供所有的中断来完成，因为无论中端是怎样引起的，有关保存寄存器的工作则是完全一样的。<br>当该例程结束后，它调用一个C过程处理处理某个特定的中断类型剩下的工作。在完成有关工作之后，大概就会使某些进程就绪接着调用调度程序，决定随后该运行哪个进程。随后将控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行。<br><img src="/2018/01/26/进程与线程（一）/4.jpg" alt="中断发生后操作系统最底层的工作步骤"><h2 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h2>采用多道程序设计可以提高CPU的利用率。严格的说，如果进程用于计算的平均时间是进程在内存中停留时间的20%，且内存中同时有5个进程，则CPU将一直满负载运行。然而，整个模型在现实中过于乐观，因为它假设这5个进程不会同时等待I/O。<br>更好的模型是从概率的角度来看CPU的利用率。假设一个进程等待I/O操作的时间与其停留在内存中的时间比为p。当内存中同时有n个进程时，则所有n个进程都在I/O的概率是Pn（幂指数）。CPU的利用率由下面的公式给出：<br>CPU利用率 = 1-Pn<br>图3以n为变量的函数表示了CPU的利用率，n称为多道程序设计的道数。如果进程花费80%的时间等待I/O，为使CPU的浪费低于10%，至少要有10个进程同时存在内存中。<br>进程不是独立的。更精确的模型应该由排队论构建，但我们的模型（当进程就绪时，给进程分配CPU，否则让CPU空转）仍然是有效的，即使真实曲线会与图3略有不同。<br><span style="border-bottom:2px dashed blue;">图3对预测cpu的性能很有效。例如：假设计算机有8GB的内存，操作系统及相关表格占用2GB，每个用户程序也占用2GB。这些内存空间允许3个用户程序同时驻留在内存中。若80%的时间用于I/O等待，这CPU的利用率大约是1-(0.8<em>0.8</em>0.8),即大约是49%.在增加8GB的内存后可从3道程序设计提高到7道程序设计，此时CPU的利用率提高到79%。提高了30%的吞吐量。增加第三个8GB的内存，CPU的利用率提高到91%，吞吐量的提高仅为12%.则第二次增加内存是不划算的。</span><br>因此，盲目提高内存，有时提高不了多少性能，它还与系统等待I/O的时间、CPU的性能有关。<br><img src="/2018/01/26/进程与线程（一）/5.jpg" alt="CPU利用率是内存中进程数目的函数"></li>
</ul>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/tags/进程与线程/">进程与线程</a>
            
        </div>
        
    </article>
    
    <p>本文代表个人观点，内容仅供参考。若有不恰当之处，望不吝赐教！</p>
    
    
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about"  title="关于本站">关于本站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="help" >急救中心</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/app" title="App下载">App下载</a>
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©2017 基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
            ，作者<a href="https://www.tangkunyin.com" target="_blank">唐先森</a>
            ，Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        

    </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '01/20/2018',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>
